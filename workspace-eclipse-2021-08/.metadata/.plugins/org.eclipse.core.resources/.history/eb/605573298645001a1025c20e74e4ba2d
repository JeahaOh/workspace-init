var CONTEXTROOT = $('#contextPath').val();
var GEOSERVER_URL = 'http://192.168.0.151:8080/geoserver/';
 //var GEOSERVER_URL = 'http://118.220.143.150:8081/geoserver/';

// 홈화면, 이전화면을 위한 배열 ---------------------------------------------
var movePosition = [];
var favoriteList = [];

// 레이어
var raster = new ol.layer.Tile({
    source: new ol.source.OSM({
//      url: 'http://xdworld.vworld.kr:8080/2d/Base/service/{z}/{x}/{y}.png',
    	url: 'http://192.168.0.151:3000/tiles/{z}/{x}/{y}.png',
        crossOrigin: "anonymous"
    }),
    crossOrigin: "anonymous"
});

/* 가상선박 소스, 레이어 */
let virtualSource = new ol.source.Vector({
    wrapX: false,
    crossOrigin: "anonymous"
});
let virtualLayer = new ol.layer.Vector({
    source: virtualSource,
    crossOrigin: "anonymous"
});


/*
 *  Basic Source, Vector Layer
 */
var source = new ol.source.Vector({
    crossOrigin: "anonymous"
});
var vector = new ol.layer.Vector({
    crossOrigin: "anonymous",
    source: source,
    style: function (feature, resolution) {
        return new ol.style.Style({
            fill: new ol.style.Fill({
                color: '#415a9ee0'
            }),
            stroke: new ol.style.Stroke({
                color: '#464646e8',
                width: 2,
                lineDash: [4, 8],
                lineDashOffset: 6
            }),
            image: new ol.style.Circle({
                radius: 3,
                fill: new ol.style.Fill({
                    color: '#2b2b2b70'
                })
            }),
            text: new ol.style.Text({
                text: '',
                fill: new ol.style.Fill({
                    color: '#464646e8'
                }),
                font: '14px sans-serif'
            })
        });
    }
});


/*
 *  소광구 Source, Vector Layer
 */
var smallSource = new ol.source.Vector({
    crossOrigin: "anonymous"
});

var smallVector = new ol.layer.Vector({
    source: smallSource,
    style: function (feature, resolution) {
        return new ol.style.Style({
            fill: new ol.style.Fill({
                color: '#e94c88'
            }),
            stroke: new ol.style.Stroke({
                color: '#7ec43d',
                width: 2,
                lineDash: [4, 8],
                lineDashOffset: 6
            }),
            image: new ol.style.Circle({
                radius: 7,
                fill: new ol.style.Fill({
                    color: '#669c336e'
                })
            }),
            text: new ol.style.Text({
                text: '소광구',
                fill: new ol.style.Fill({
                    color: '#FFFFFF'
                }),
                font: '14px sans-serif'
            })
        });
    },
    crossOrigin: "anonymous"
});

var style = new ol.style.Style({
    fill: new ol.style.Fill({
        color: '#e7e7e71a'
    }),
    stroke: new ol.style.Stroke({
        color: '#494949',
        width: 2
    }),
    image: new ol.style.Circle({
        radius: 7,
        fill: new ol.style.Fill({
            color: '#ffcc33'
        })
    }),
    text: new ol.style.Text({
        text: $('#areaSmallName').val(),
        fill: new ol.style.Fill({
            color: '#5422c9'
        }),
        font: '16px sans-serif'
    })
});

var gridStyle = new ol.style.Style({
    fill: new ol.style.Fill({
        color: 'rgba(255, 255, 255, 0)'
    }),
    stroke: new ol.style.Stroke({
        color: '#818181',
        width: 1
    })
});

var bigStyle = new ol.style.Style({
    fill: new ol.style.Fill({
        color: 'rgba(31, 97, 182, 0.808)'
    }),
    stroke: new ol.style.Stroke({
        color: '#1368d6',
        width: 2
    }),
    text: new ol.style.Text({
        text: '',
        fill: new ol.style.Fill({
            color: '#ffffff'
        }),
        font: '14px sans-serif'
    })
});

var selectStyle = new ol.style.Style({
    fill: new ol.style.Fill({
        color: '#bb2121c7'
    }),
    stroke: new ol.style.Stroke({
        color: '#bb2121',
        width: 2
    }),
    text: new ol.style.Text({
        text: 'Selected',
        fill: new ol.style.Fill({
            color: '#ffffff'
        }),
        font: '14px sans-serif'
    })
});



// 기본 맵 설정 (Default Map) -------------------------------------------------------
var map = new ol.Map({
    target: 'map',
    autoPan: false,
    layers: [
        raster,
        vector,
        smallVector,
        virtualLayer
        ],
    view: new ol.View({
        // 맵 센터 포지션 지정
        center: new ol.proj.fromLonLat([127, 34.7]),
        // 맵 최대 영역 제한
        extent: new ol.proj.transformExtent([117, 31, 141, 42], 'EPSG:4326', 'EPSG:3857'),
        // 기본 줌 레벨 설정
        zoom: 9,
        // 최소 줌 레벨 설정
        minZoom: 7,
        maxZoom: 19,
        constrainRotation: false
    }),
    crossOrigin: "anonymous"
});

/*
 *  객체 Source, Vector Layer
 */
let objSource = new ol.source.Vector({
    wrapX: false,
    crossOrigin: "anonymous"
});
let objVector = new ol.layer.Vector({
  source: objSource,
  style: new ol.style.Style({
    fill: new ol.style.Fill({
      color: 'rgba(255, 255, 255, 0.1)'
    }),
    stroke: new ol.style.Stroke({
      color: '#000000',
      width: 2
    }),
    image: new ol.style.Circle({
      radius: 7,
      fill: new ol.style.Fill({
        color: '#ffcc33'
      })
    }),
    text: new ol.style.Text({
      font: '12px Verdana',
      scale: 3,
      text: '',
    })
  }),
  crossOrigin: "anonymous"
});

map.addLayer(objVector);

/*
 *  거리측정 Source, Vector Layer
 */
let measureSource = new ol.source.Vector({
    wrapX: false,
    crossOrigin: "anonymous"
});
let measureVector = new ol.layer.Vector({
  source: measureSource,
  crossOrigin: "anonymous"
});


// 한국 EEZ -------------------------------------------------------------------------
var wmsSource3 = new ol.source.TileWMS({
    url: GEOSERVER_URL + 'eez/wms?',
    params: {
        'LAYERS': 'eez:area',
        'TILED': true
    },
    serverType: 'geoserver',
    projection: 'EPSG:3857',
    transition: 0,
    crossOrigin: "anonymous"
});

var wmsLayer3 = new ol.layer.Tile({
    source: wmsSource3,
    crossOrigin: "anonymous"
});

map.addLayer(wmsLayer3);





// 대광구 레이어 ON -------------------------------------------------------------------------
var bigAreaSource;
var bigAreaLayer;

function fn_bigAreaLayerOn() {
    bigAreaSource = new ol.source.Vector({
        format: new ol.format.GeoJSON(),
        url: 'http://192.168.0.151:8080/geoserver/bigmine/wfs?service=WFS&' +
              'version=1.0.0&request=GetFeature&typename=bigmine:tbarea&' +
              'outputFormat=application/json&srsname=EPSG:4326'
    });

    console.log(bigAreaSource);
    
    bigAreaLayer = new ol.layer.Vector({
        source: bigAreaSource,
        crossOrigin: "anonymous",
        style: bigStyle
    });

    map.addLayer(bigAreaLayer);
}

fn_bigAreaLayerOn();

// 대광구 레이어 OFF
function fn_bigAreaLayerOff() {
    map.removeLayer(bigAreaLayer);
}

//격자 WFS  레이어 -------------------------------------------------------------------------
var areaGridSource;
var areaGridLayer;


function fn_gridLayerOn() {
	areaGridSource = new ol.source.Vector({
	    format: new ol.format.GeoJSON(),
	    url: 'http://192.168.0.151:8080/geoserver/grid/wfs?service=WFS&' +
	          'version=1.0.0&request=GetFeature&typename=grid:tbarea_grid&' +
	          'outputFormat=application/json&srsname=EPSG:4326'
	});
	
	areaGridLayer = new ol.layer.Vector({
        source: areaGridSource,
        crossOrigin: "anonymous",
        style: gridStyle
	});
	
    map.addLayer(areaGridLayer);
}

fn_gridLayerOn();

function fn_gridLayerOff() {
    map.removeLayer(areaGridLayer);
}



/*
    var gridTile = new ol.layer.Graticule({
        strokeStyle: new ol.style.Stroke({
            color: '#000',
            width: 1,
            lineDash: [0.5, 2]
        }),
        targetSize: 256,
        showLabels: true,
        wrapX: false
    })

    map.addLayer(gridTile);

    map.on('click', function(e){
        console.log(e);
    });
*/



/* 그리드 레이어

	const grid = new ol.source.OSM().getTileGrid({
	  tileSize:[256, 256]
	});

	var grildTile = new ol.layer.Tile({
	  source: new ol.source.TileDebug({
	    tileGrid: grid,
	    projection:'EPSG:4326'
	  })
	});

	const highlightVector = new ol.source.Vector();
	const highlightLayer = new ol.layer.Vector({
	  source: highlightVector,
	  style: new ol.style.Style({
	    stroke: new ol.style.Stroke({
	      width: 3,
	      color: [255, 0, 0, 1]
	    })
	  })
	});

	map.addLayer(grildTile);
	map.addLayer(highlightLayer);


	map.on('singleclick',function(event){
		console.log(event.target);
        var z = map.getView().getZoom();
        var coord = grid.getTileCoordForCoordAndZ(event.coordinate, z);
        var extent = grid.getTileCoordExtent(coord);

        highlightVector.clear();
        highlightVector.addFeature(new ol.Feature({
            geometry: new ol.geom.LineString([
            [ extent[0],extent[1] ],
            [ extent[0],extent[3] ],
            [ extent[2],extent[3] ],
            [ extent[2],extent[1] ],
            [ extent[0],extent[1] ],
            ])
        }));
    });
    
    map.on('singleclick',function(event){
        var z = map.getView().getZoom();
        var coord = grid.getTileCoordForCoordAndZ(event.coordinate, z);
        var extent = grid.getTileCoordExtent(coord);

        highlightVector.clear();
        highlightVector.addFeature(new ol.Feature({
        geometry: new ol.geom.LineString([
            [ extent[0],extent[1] ],
            [ extent[0],extent[3] ],
            [ extent[2],extent[3] ],
            [ extent[2],extent[1] ],
            [ extent[0],extent[1] ],
        ])
        }));
    });
*/


/* 가상선박 체크 */
function fn_virtualShipFeature() {
    var virtualShips = JSON.parse(localStorage.getItem('virtual-ship'));
    virtualSource.clear();
    if(virtualShips !== null) {
        $.each(virtualShips, function(idx) {
            if(virtualShips[idx].shipHide === 'false') {
                var virtualFeature = new ol.Feature({
                    geometry: new ol.geom.Point([Number(virtualShips[idx].shipLat), Number(virtualShips[idx].shipLon)])
                });
    
                var virtualStyle = new ol.style.Style({
                    fill: new ol.style.Fill({
                        color: '#d31c04'
                    }),
                    stroke: new ol.style.Stroke({
                        color: '#d31c04',
                        width: 2,
                        lineDash: [4, 8],
                        lineDashOffset: 6
                    }),
                    image: new ol.style.Icon(({
                        anchor: [0.5, 0.5],
                        anchorOrigin: 'top-left',
                        offset: [0, 0],
                        scale: 1,
                        opacity: 1,
                        rotateWithView: false,
                        src: 'images/vessel/vessel_red.png',
                    }))
                });
    
                virtualFeature.setStyle(virtualStyle);
                virtualSource.addFeature(virtualFeature);
                
            }
        });
    }
}

fn_virtualShipFeature();




// Feature Select 이벤트 추가 -----------------------------------------------------------
var selectClick = new ol.interaction.Select({
    condition: ol.events.condition.click
});
map.addInteraction(selectClick);
    





// 화면이동 완료 후, 현재 좌표값 저장하기 ------------------------------------------------------
map.on('moveend', function() {
    if(movePosition.length === undefined) {
        movePosition[0] = map.getView().getCenter();        	        		
    } else {
        movePosition[movePosition.length] = map.getView().getCenter();
    }
});




// GeoServer WFS Layer 불러오기 --------------------------------------------------------------
// var wmsSource = new ol.source.Vector({
//     format: new ol.format.GeoJSON(),
//     url: 'http://localhost:8800/geoserver/wfs?service=WFS&' +
//             'version=1.0.0&request=GetFeature&typename=test:area&' +
//             'outputFormat=application/json&srsname=EPSG:4326'
// });

// var wmsLayer = new ol.layer.Vector({
//     source: wmsSource
// });

// var wmsSource2 = new ol.source.TileWMS({
//     url: 'http://localhost:8800/geoserver/wms',
//     params: {
//         'LAYERS': 'test:gmt_area',
//         'TILED': false,
//     },
//     serverType: 'geoserver',
//     projection: 'EPSG:4326',
//     transition: 0
// });

// var wmsLayer2 = new ol.layer.Tile({
//     source: wmsSource2
// });

// map.addLayer(wmsLayer);
// map.addLayer(wmsLayer2);





// 지도 스케일 바 표출 -------------------------------------------------------------------
var control = new ol.control.ScaleLine({
    units: 'metric',
    bar: true,
    steps: 1,
    minWidth: 90
  });

map.addControl(control);




// 현재 마우스 포지션 -------------------------------------------------------------------
map.on('pointermove', function(evt) {
    var lonlat = evt.coordinate;
    var lon = lonlat[0].toFixed(5);
    var lat = lonlat[1].toFixed(5);

    var hdms = ol.coordinate.toStringHDMS(ol.proj.transform(lonlat, 'EPSG:3857', 'EPSG:4326'));

    //$('#curPos').html('Lon : ' + lon + '　Lat : ' + lat);
    $('#curPos').html(hdms);
});


// 대광구 생성 (그리기툴) ---------------------------------------------------------------------------------
function fn_createBigAreaDraw() {
	if($('#bigAreaName').val().trim().length === 0) {
		alert('대광구 명을 입력해주세요.');
		$('#bigAreaName').focus();
		return false;
	}
	if($('#createGridFlag').prop("checked")) {
		if($('#gridDistance').val().trim().length === 0) {
			alert('격자 간격을 입력해주세요. (단위:Meter)');
			$('#gridDistance').focus();
			return false;
		}
	}
	
        var draw, snap; // global so we can remove them later
        var featureCollection = new ol.Collection();
        var drawFeature = new ol.Feature({});

        function addInteractions() {
            draw = new ol.interaction.Draw({
                type: 'Polygon',
                features: featureCollection
            });

            map.addInteraction(draw);

            snap = new ol.interaction.Snap({
                source: source
            });

            //map.addInteraction(snap);
            map.addInteraction(selectClick);

            var format = new ol.format.WKT();
            var src = 'EPSG:3857';
            var dest = 'EPSG:4326';
            
            draw.on('drawend', function (e) {
                var currentFeature = e.feature;
                var coord = currentFeature.getGeometry().getCoordinates()[0];
                var resultPoint1, resultPoint2, resultPoint3, resultPoint4;
                var resultArr;
                
                // 비교할 대상 첫 포인트 담아두고 최대값 X,Y 갱신
                var x = coord[0][0];
                var y = coord[0][1];

                // 비교할 대상 첫 포인트 담아두고 최소값 X,Y 갱신
                var minX = coord[0][0];
                var minY = coord[0][1];

                // 전송 성공한 격자 카운트
                var createGridSuccess = 0;

                // 전송 완료 체크
                var createComplete = false;

                loaderTileOn("격자 생성 중");

                /**
                 * Promise minXY
                 */
                var minXy = function (coord) {
                    return new Promise(function (resolve, reject) {
                        // 비교하여 최대, 최소 X, Y 값 담기
                        $.each(coord, function(idx) {
                            //console.log("Coordinate 길이 : " + coord.length);
                            if(idx !== 0) {
                                // X 최대값 갱신
                                if(x < coord[idx][0]) {
                                    x = coord[idx][0];
                                }
                                // X 최소값 갱신
                                if(coord[idx][0] < minX) {
                                    minX = coord[idx][0];
                                }
                                // Y 최대값 갱신
                                if(y < coord[idx][1]) {
                                    y = coord[idx][1];
                                }
                                // Y 최소값 갱신
                                if(coord[idx][1] < minY) {
                                    minY = coord[idx][1];
                                }
                            }
                        });
                    
                        resultPoint1 = [minX, y];   // 상좌
                        resultPoint2 = [x, y];   // 상우
                        resultPoint3 = [x, minY];   // 하우
                        resultPoint4 = [minX, minY];   // 하좌
                        resultArr = [resultPoint1, resultPoint2, resultPoint3, resultPoint4, resultPoint1];
                        
                        // 최대최소 XY 값을 담은 배열을 되돌려줌
                        resolve(resultArr);
                    });
                };

                minXy(coord)
                .then(function (resultArr) {
                    // 위에서 생성한 좌표배열로 WKT를 만들기
                    var bigMineArea = new ol.Feature({
                        geometry: new ol.geom.Polygon([coord])
                    });

                    bigMineArea.getGeometry().transform(src, dest);
                    var wkt = format.writeFeature(bigMineArea);
                    console.log(wkt);

                    // WKT를 반환
                    return wkt;
                }).then(function (wkt) {
                    function fn_insertArea() {
                        $.ajax({
                            type: 'POST',
                            url: '/area/insertArea.do',
                            data: {
                                "tbareaName":$('#bigAreaName').val(), 
                                "tbareaCategory": "대광구", 
                                "tbareaType":"Polygon", 
                                "tbareaGeom": String(wkt)
                            },
                            success: function(data) {
                                $('#bigAreaName').val('');
                                $('#gridDistance').val('');
                            },
                            error: function(req, status, err) {
                                console.log(req);
                                console.log(status);
                                console.log(err);
                            },
                            fail: function(data) {
                                console.log(data);
                            }
                        });
                    }
                    
                    fn_insertArea();
                    
                    return $('#createGridFlag').prop("checked");
                })
                .then(function (check) {
                    if(check) {     // 격자 생성 여부에 격자 생성 진행

                        var gridDistance = $('#gridDistance').val();		// 격자 간격을 불러와 담아둠 (단위 :Meter)
                        console.log("격자 생성 할꺼임");
                        
                        // TurfJS -> 거리측정 
                        var point = turf.point(ol.proj.toLonLat([minX, y]));
                        var distance = gridDistance/1000;
                        var bearing = 90;
                        var options = {units: 'kilometers'};

                        var destination = turf.destination(point, distance, bearing, options);

                        var kiloFeature = new ol.format.GeoJSON().readFeatures(destination);
                        kiloFeature[0].getGeometry().transform('EPSG:4326', 'EPSG:3857');
                        
                        var kilo = kiloFeature[0].getGeometry().getCoordinates()[0] - minX;
                        console.log('최소 X값으로 부터 1키로미터 위치 :: ' + kiloFeature[0].getGeometry().getCoordinates()[0]);
                        console.log('시작 포인트 :: ' + minX);
                        console.log('1키로 :: ' + kilo);
                        
                        // X
                        var from = turf.point(ol.proj.toLonLat([minX, y]));
                        var to = turf.point(ol.proj.toLonLat([x, y]));
        
                        var resultDistance = turf.distance(from, to, options);
        
                        // Y
                        var fromY = turf.point(ol.proj.toLonLat([minX, y]));
                        var toY = turf.point(ol.proj.toLonLat([minX, minY]));
        
                        var resultDistanceY = turf.distance(fromY, toY, options);
        
                        console.log('minX ~ X 거리 :: ' + resultDistance);
                        console.log('거리 (km -> meters) /사용자 입력거리 (가로개수) :: ' + (resultDistance * 1000)/(gridDistance));
                        //console.log('거리 (km -> meters) /사용자 입력거리 (가로개수) :: ' + (resultDistance * 1000)/(gridDistance));
        
                        var xCount = Math.ceil((resultDistance * 1000)/(gridDistance));
                        var yCount = Math.ceil((resultDistanceY * 1000)/(gridDistance)) + 1;
                        console.log(xCount);
                        console.log(yCount);
                        
                        // 이제 격자 만들기
                        var point1_X = resultArr[0][0];
                        var point1_Y = resultArr[0][1];
        
                        var point2_X = resultArr[1][0];
                        var point2_Y = resultArr[1][1];
        
                        var point3_X = resultArr[2][0];
                        var point3_Y = resultArr[2][1];
        
                        var point4_X = resultArr[3][0];
                        var point4_Y = resultArr[3][1];
        
                        // 가로 값
                        var g = [];
                        // 세로 값
                        var s = [];
        
                        var g1, g2;
                        var s1, s2;
        
                        for (var i = 0; i <= xCount; i++) {
                            if (i == 0) {
                                g1 = point1_X;
                                g[i] = g1;
                            } else {
                                //g2 = (point2_X - point1_X) / kilo;
                                if(g1 <= x) {
                                    g2 = kilo;
                                    g[i] = g1 + g2;
                                    g1 = g[i];
                                } else {
                                    g[i] = x;
                                    break;
                                }
                            }
                        }
        
                        for (var j = 0; j <= yCount; j++) {
                            if (j == 0) {
                                s1 = point1_Y;
                                s[j] = s1;
                            } else {
                                if(s1 > minY) {
                                    s2 = kilo;
                                    s[j] = s1 - s2;
                                    s1 = s[j];
                                } else {
                                    s[j] = minY;
                                    break;
                                }
                            }
                        }

                        var test = [];
                        var num = 0;
        
                        $.each(s, function (j) {
                            $.each(g, function (i) {
                                if (num == 0) {
                                    test[num] = [
                                        [
                                            [g[i], s[j]],
                                            [g[i + 1], s[j]],
                                            [g[i + 1], s[j + 1]],
                                            [g[i], s[j + 1]],
                                            [g[i], s[j]]
                                        ]
                                    ];
                                    num++;
                                } else if (num != (g.length * s.length)) {
                                    if ((i + 1) <= g.length - 1 && (j + 1) <= s.length -
                                        1) {
                                        test[num] = [
                                            [
                                                [g[i], s[j]],
                                                [g[i + 1], s[j]],
                                                [g[i + 1], s[j + 1]],
                                                [g[i], s[j + 1]],
                                                [g[i], s[j]]
                                            ]
                                        ];
                                        num++;
                                    }
                                } else {
                                    console.log("ccc");
                                }
                            });
                        });

                        return test;
                    } // check END.
                }) // Promise then (check) END.
                .then(function (test) {
                	
                    delay(250);
                	
                    var insertGrid = $.ajax({
                    	type: 'GET', url: 'area/selectAreaSeq.do'});
                    
                    insertGrid.done(function(data) {
                    	var result = JSON.parse(data).areaSeq;
                    	
                    	fn_gridLayerOff();
                        $.each(test, function (idx, item) {
                            $('#loader_process').text(test.length-1);
                            var gridFeature = new ol.Feature({
                                geometry: new ol.geom.Polygon(test[idx])
                            });
                            gridFeature.setStyle(gridStyle);
                            //vector.getSource().addFeature(gridFeature);
                            gridFeature.getGeometry().transform(src, dest);
                            var gridWkt = format.writeFeature(gridFeature);
                            
                            
                    	   $.ajax({
                    		   type: 'POST',
                    		   url: 'area/insertGrid.do',
                    		   data: {
                           		"tbareaId" : result,
                                "tbareaGridGeom" : String(gridWkt)
                    		   },
                    		   success: function(data) {
                               	$('#loader_success').text(idx);
                                   if(idx === test.length-1) {
                                       fn_createGridEnd();
                                   }
                    		   }
                            });
                    });
                        	
                    
                    
                        
                    }); // Each END.
                });

                function fn_createGridEnd() {
                    fn_bigAreaLayerOff();
                    delay(1000);
                    fn_bigAreaLayerOn();
                    delay(1000);
                    // 격자 레이어 리로드
                    fn_gridLayerOn();
                    delay(2000);
                    if(confirm('영역생성을 완료했습니다!\n영역 목록으로 가시겠습니까?')) {
                        loaderTileOff();
                        fn_areaList();
                    } else {
                        loaderTileOff();
                    }
                }

                map.removeInteraction(draw);
            }); // Drow END Event.
        } // Function addInteractions() END.

        addInteractions();
        $('#areaCreatePanel-draw').css({"display":"none"});
}


// 대광구 생성 (좌표지정) ---------------------------------------------------------------------------------
function fn_createBigAreaGeom() {
    // 상좌
    var lat1 = $('input[name=lat1]').val();
    var lon1 = $('input[name=lon1]').val();
    // 상우
    var lat2 = $('input[name=lat2]').val();
    var lon2 = $('input[name=lon2]').val();
    // 하좌
    var lat3 = $('input[name=lat3]').val();
    var lon3 = $('input[name=lon3]').val();
    // 하우
    var lat4 = $('input[name=lat4]').val();
    var lon4 = $('input[name=lon4]').val();
    
    if($('#bigAreaGeomName').val().trim().length === 0) {
        $('#geomValidate').html('<b>대광구 명을 입력해주세요.</b>');
        $('#bigAreaGeomName').focus();
        return false;
    }
    if($('#createGridFlagGeom').prop("checked")) {
		if($('#gridGeomDistance').val().trim().length === 0) {
			alert('격자 간격을 입력해주세요. (단위:Meter)');
			$('#gridGeomDistance').focus();
			return false;
		}
	}
    if(lat1 === null || lat1 === '') {
        $('#geomValidate').html('<b>"상좌" 위도를 입력해주세요!</b>');
        $('input[name=lat1]').focus();
        return false;
    }
    if(lon1 === null || lon1 === '') {
        $('#geomValidate').html('<b>"상좌" 경도를 입력해주세요!</b>');
        $('input[name=lon1]').focus();
        return false;
    }
    if(lat2 === null || lat2 === '') {
        $('#geomValidate').html('<b>"상우" 위도를 입력해주세요!</b>');
        $('input[name=lat2]').focus();
        return false;
    }
    if(lon2 === null || lon2 === '') {
        $('#geomValidate').html('<b>"상우" 경도를 입력해주세요!</b>');
        $('input[name=lon2]').focus();
        return false;
    }
    if(lat3 === null || lat3 === '') {
        $('#geomValidate').html('<b>"하좌" 위도를 입력해주세요!</b>');
        $('input[name=lat3]').focus();
        return false;
    }
    if(lon3 === null || lon3 === '') {
        $('#geomValidate').html('<b>"하좌" 경도를 입력해주세요!</b>');
        $('input[name=lon3]').focus();
        return false;
    }
    if(lat4 === null || lat4 === '') {
        $('#geomValidate').html('<b>"하우" 위도를 입력해주세요!</b>');
        $('input[name=lat4]').focus();
        return false;
    }
    if(lon4 === null || lon4 === '') {
        $('#geomValidate').html('<b>"하우" 경도를 입력해주세요!</b>');
        $('input[name=lon4]').focus();
        return false;
    }

		    var coord = [
		        new ol.proj.transform([parseFloat(lat1), parseFloat(lon1)], 'EPSG:4326', 'EPSG:3857'), 
		        new ol.proj.transform([parseFloat(lat2), parseFloat(lon2)], 'EPSG:4326', 'EPSG:3857'),
		        new ol.proj.transform([parseFloat(lat3), parseFloat(lon3)], 'EPSG:4326', 'EPSG:3857'),
		        new ol.proj.transform([parseFloat(lat4), parseFloat(lon4)], 'EPSG:4326', 'EPSG:3857'),
		        new ol.proj.transform([parseFloat(lat1), parseFloat(lon1)], 'EPSG:4326', 'EPSG:3857')
		    ];
		    console.log(coord);
		
		    var resultPoint1, resultPoint2, resultPoint3, resultPoint4;
		    var resultArr;

		    // 상우 X
		    var x = coord[1][0];
		    // 상  Y
		    var y = coord[0][1];
		    // 상좌 X
		    var minX = coord[0][0];
		    // 하 Y
		    var minY = coord[3][1];
    
		    console.log("최대 X 값");
		    console.log(x);
		    console.log("최대 Y 값");
		    console.log(y);
		    console.log("최소 X 값");
		    console.log(minX);
		    console.log("최소 Y 값");
		    console.log(minY);

		    resultPoint1 = [minX, y];   // 상좌
		    resultPoint2 = [x, y];   // 상우
		    resultPoint3 = [x, minY];   // 하우
		    resultPoint4 = [minX, minY];   // 하좌
		    resultArr = [resultPoint1, resultPoint2, resultPoint3, resultPoint4, resultPoint1];
		    console.log(resultArr);

		    var testingFeature = new ol.Feature({
		        geometry: new ol.geom.Polygon([resultArr])
		    });
		
		    console.log(testingFeature);
		
		    testingFeature.setStyle(bigStyle);
		    //vector.getSource().addFeature(testingFeature);
		
		    var areaTextFeature = new ol.Feature({
		        geometry: new ol.geom.Point([(minX + 100), (y + 60)])
		    });
		
		    var areaTextStyle = new ol.style.Style({
		        text: new ol.style.Text({
		            text: $('#bigAreaGeomName').val(),
		            fill: new ol.style.Fill({
		                color: '#3f3f3f'
		            }),
		            font: '14px sans-serif',
		            scale: 2
		        })
		    });

            areaTextFeature.setStyle(areaTextStyle);
            //vector.getSource().addFeature(areaTextFeature);
            
            var format = new ol.format.WKT();
            var src = 'EPSG:3857';
            var dest = 'EPSG:4326';
            testingFeature.getGeometry().transform(src, dest);
            var wkt = format.writeFeature(testingFeature);

            // [1] --------------------------------------------------------------------------------------------------------- 대광구 INSERT
            $.ajax({
                type: 'POST',
                url: '/area/insertArea.do',
                data: {
                	"tbareaName":$('#bigAreaGeomName').val(), 
                	"tbareaCategory": "대광구", 
                	"tbareaType":"Polygon", 
                	"tbareaGeom": String(wkt)
                },
                success: function(data) {
                	var resultData = JSON.parse(data);
                	sessionStorage.setItem("bigMineLastSeq", resultData.LAST_SEQ+1);
                	
                    $('#bigAreaGeomName').val('');
                    $('#gridGeomDistance').val('');
                },
                error: function(req, status, err) {
                    console.log(req);
                    console.log(status);
                    console.log(err);
                },
                fail: function(data) {
                    console.log(data);
                }
            });
            // [1] --------------------------------------------------------------------------------------------------------- 대광구 INSERT END
            // 격자 생성 여부에 따른 Part [2] 진행 여부
            
            if($('#createGridFlagGeom').prop('checked')) {
		            var gridDistance = $('#gridGeomDistance').val();
		
		            var point = turf.point(ol.proj.toLonLat([minX, y]));
		            var distance = gridDistance/1000;
		            var bearing = 90;
		            var options = {units: 'kilometers'};
		
		            var destination = turf.destination(point, distance, bearing, options);
		
		            var kiloFeature = new ol.format.GeoJSON().readFeatures(destination);
		            kiloFeature[0].getGeometry().transform('EPSG:4326', 'EPSG:3857');
		
		            var kilo = kiloFeature[0].getGeometry().getCoordinates()[0] - minX;
		            console.log('최소 X값으로 부터 1키로미터 위치 :: ' + kiloFeature[0].getGeometry().getCoordinates()[0]);
		            console.log('시작 포인트 :: ' + minX);
		            console.log('1키로 :: ' + kilo);
		
		            // X
		            var from = turf.point(ol.proj.toLonLat([minX, y]));
		            var to = turf.point(ol.proj.toLonLat([x, y]));
		
		            var resultDistance = turf.distance(from, to, options);
		
		            // Y
		            var fromY = turf.point(ol.proj.toLonLat([minX, y]));
		            var toY = turf.point(ol.proj.toLonLat([minX, minY]));
		
		            var resultDistanceY = turf.distance(fromY, toY, options);
		
		            
		            console.log('minX ~ X 거리 :: ' + resultDistance);
		            console.log('거리 (km -> meters) /사용자 입력거리 (가로개수) :: ' + (resultDistance * 1000)/(gridDistance));
		            //console.log('거리 (km -> meters) /사용자 입력거리 (가로개수) :: ' + (resultDistance * 1000)/(gridDistance));
		
		            var xCount = Math.ceil((resultDistance * 1000)/(gridDistance));
		            var yCount = Math.ceil((resultDistanceY * 1000)/(gridDistance)) + 1;
		            console.log(xCount);
		            console.log(yCount);
		            
		            /*
		                TurfJS, squareGrid 사용
		                bbox = minX, minY, maxX, maxY
		                cellSide는 units에 설정된 값에 따른 격자 하나의 크기
		                option = default(kilometers), miles, degrees, radians
		            
		                var bbox = [minX, minY, x, y];
		                var cellSide = 150;
		                var optionss = {units: 'kilometers'};
		
		                var squareGrid = turf.squareGrid(bbox, cellSide, optionss);
		                // 생성된 squareGrid를 Feature로 변환
		                var squareGirdFeature = new ol.format.GeoJSON().readFeatures(squareGrid);
		                console.log(squareGirdFeature);
		                source.addFeatures(squareGirdFeature);
		            */
		        
		            //console.log("결과 배열");
		            //console.log(resultArr[0][0]);
		            //console.log(resultArr[0][1]);
		
		            // 이제 격자 만들기
		            var point1_X = resultArr[0][0];
		            var point1_Y = resultArr[0][1];
		
		            var point2_X = resultArr[1][0];
		            var point2_Y = resultArr[1][1];
		
		            var point3_X = resultArr[2][0];
		            var point3_Y = resultArr[2][1];
		
		            var point4_X = resultArr[3][0];
		            var point4_Y = resultArr[3][1];
		
		            // 가로 값
		            var g = [];
		            // 세로 값
		            var s = [];
		
		            var g1, g2;
		            var s1, s2;
		
		            for (var i = 0; i <= xCount; i++) {
		                if (i == 0) {
		                    g1 = point1_X;
		                    g[i] = g1;
		                } else {
		                    //g2 = (point2_X - point1_X) / kilo;
		                    if(g1 <= x) {
		                        g2 = kilo;
		                        g[i] = g1 + g2;
		                        g1 = g[i];
		                    } else {
		                        g[i] = x;
		                        break;
		                    }
		                }
		            }
		
		            for (var j = 0; j <= yCount; j++) {
		                if (j == 0) {
		                    s1 = point1_Y;
		                    s[j] = s1;
		                } else {
		                    if(s1 > minY) {
		                        s2 = kilo;
		                        s[j] = s1 - s2;
		                        s1 = s[j];
		                    } else {
		                        s[j] = minY;
		                        break;
		                    }
		                }
		            }
		
		            var test = [];
		            var num = 0;
		
		            $.each(s, function (j) {
		                $.each(g, function (i) {
		                    if (num == 0) {
		                        test[num] = [
		                            [
		                                [g[i], s[j]],
		                                [g[i + 1], s[j]],
		                                [g[i + 1], s[j + 1]],
		                                [g[i], s[j + 1]],
		                                [g[i], s[j]]
		                            ]
		                        ];
		                        num++;
		                    } else if (num != (g.length * s.length)) {
		                        if ((i + 1) <= g.length - 1 && (j + 1) <= s.length -
		                            1) {
		                            test[num] = [
		                                [
		                                    [g[i], s[j]],
		                                    [g[i + 1], s[j]],
		                                    [g[i + 1], s[j + 1]],
		                                    [g[i], s[j + 1]],
		                                    [g[i], s[j]]
		                                ]
		                            ];
		                            num++;
		                        }
		
		                    } else {
		                        console.log("ccc");
		                    }
		                });
		            });
        
                    console.log("현재 대광구 아이디 : " + sessionStorage.getItem('bigMineLastSeq'));
                    
		            $.each(test, function (idx, item) {
		                if (idx < test.length) {
		                    var gridGeomFeature = new ol.Feature({
		                        geometry: new ol.geom.Polygon(test[idx])
		                    });
		                    gridGeomFeature.setStyle(gridStyle);
		                    //vector.getSource().addFeature(testFeature);
		                    gridGeomFeature.getGeometry().transform(src, dest);
		                    var gridGeomWkt = format.writeFeature(gridGeomFeature);
		                    
		                    $.ajax({
		                    	type: 'POST',
		                    	url: 'area/insertGrid.do',
		                    	data: {
		                    		"tbareaId" : sessionStorage.getItem('bigMineLastSeq'),
		                    		"tbareaGridGeom" : String(gridGeomWkt)
		                    	},
		                    	success: function(data) {
		                    		console.log(idx);
		                    		console.log(data);
		                    	},
		                    	error: function(data) {
		                    		console.log(data);
		                    	},
		                    	fail: function(data) {
		                    		console.log(data);
		                    	}
		                    });
		                }
		            });
            
            }
    
            $('#areaCreatePanel-geom').css({"display":"none"});
}
            

// Feature Select Event ------------------------------------------------------------------------
selectClick.on('select', function (evt) {
  console.group('selectClick.on Select');
    snap = new ol.interaction.Snap({
        source: [source]
    });

    if (evt.selected[0]) {
        console.log("----------------------------------------");
        console.log("---- Selected Feature ID : " + evt.selected[0].getId());
        console.log("---- Selected Feature get Geometry");
        console.log(evt.selected[0].getGeometry());
        console.log("---- Selected Feature get Coordinates");
        console.log(evt.selected[0].getGeometry().getCoordinates());
        console.log("---- Selected Feature get First Coordinate");
        console.log(evt.selected[0].getGeometry().getCoordinates()[0]);
    }

  console.groupEnd('selectClick.on Select');
});


// 소광구 설정 --------------------------------------------------------------------------
$(document).on('click', '#setSmallArea', function () {
    
	var bigAreaId = $('#selectBigMineArea').val();
	
	
    let _unit = document.querySelector('input[name=effective_range_unit]:checked').value;
    let _dist = document.getElementById('effective_range_distance').value;
    //  유효범위의 거리 설정이 자유롭긴 하지만 필터링 한번 해줘야 하지 않을까 싶음.
    console.log( _dist + _unit );
    if( !confirm('유효범위의 광구와의 거리는 ' + _dist + ' ' + _unit + '입니다.') ) return;
    
    var draw, snap; // global so we can remove them later
    var featureCollection = new ol.Collection();

    function addInteractions() {
        draw = new ol.interaction.Draw({
            source: smallSource,
            type: 'Polygon',
            features: featureCollection
        });
        map.addInteraction(draw);

        snap = new ol.interaction.Snap({
            source: areaGridSource
        });
        map.addInteraction(snap);

        draw.on('drawstart', function (evt) {
          console.group('Small Area Draw Start');
             var sketch = evt.feature;
            // sketch.getGeometry().on('change', function (evt) {

            //     map.on('click', function(event) {
            //         console.log('클릭');
            //     });

            //      var geom = evt.target;
            //      var output;
            //      output = formatLength(geom);
            //      overlayPopupElement.innerHTML = output;
            //      overlayPopup.setPosition(geom.getLastCoordinate());
            // });

            //evt.feature.setId('id');
            sketch.setProperties({
                'category': 'smallArea'
            });
          console.groupEnd('Small Area Draw Start');
        });

        
/*        map.on('click', function(event) {
            console.log('클릭');
            console.log(event.coordinate);
            //createMeasureTooltip();
            var geom = event.coordinate;
            var output;
            //output = formatLength(geom);
            overlayPopupElement.innerHTML = output;
            overlayPopup.setPosition(geom.getLastCoordinate());
        });*/
        

        draw.on('drawend', function (evt) {
        	console.clear();
            console.group('Small Area Draw End');
            console.log("유효범위 만들기");

            //  대광구 ID를 가져온다.
            let bigAreaId = $('#selectBigMineArea').val();
            console.log( 'bigArea id : tbarea.' + bigAreaId )
            //  대광구를 가져온다.
            let bigArea = bigAreaSource.getFeatureById('tbarea.' + bigAreaId);
//            console.log( 'bigArea coordinates' );
//            console.log( bigArea );
            
            // 그린 featureㄹ르 소광구로 담는다.
            let smallArea = evt.feature;
            //	소광구가 대광구를 넘어간다면 자른다.
            smallArea = trimPolygon( bigArea, smallArea );
            console.log( 'smallArea' );
            console.log( smallArea );

            //	소광구를 buffer로 키운다.
            let effectiveRange = createEffectiveRangeByBuffer( smallArea.clone(), 0.1, 'kilometers' );
            console.log( 'Buffered effectiveRange Area' );
            console.log( effectiveRange );
            
            
            if( effectiveRange != null ) {
            	effectiveRange = trimPolygon( bigArea, effectiveRange );
//            	effectiveRange = trimPolygon( smallArea, effectiveRange );
            	console.log( 'Trimed effectiveRange Area' );
            	console.log( effectiveRange );
            	
            	effectiveRange.setStyle( new ol.style.Style({
            		stroke: new ol.style.Stroke({
            			color: 'red',
            			lineDash: [3, 10],
            			width: 4
            		})
            	}));
                //  임시
                objSource.addFeature(effectiveRange);
                
	            console.log('smallArea coords');
	            console.log(smallArea.getGeometry().getCoordinates());
	            
	            console.log('effectiveRange coords');
	            console.log(effectiveRange.getGeometry().getCoordinates());
	            
                console.log( "start each ")
                let gridList = areaGridSource.getFeatures().filter(function(obj) {
                    return obj.values_.tbarea_id == bigAreaId;
                });
                
//                console.log( 'gridList' );
//                console.log( gridList );

                let effectiveList = [];

	            $.each( gridList, function( idx, grid ) {
//	            	console.log( bigAreaId );
//	            	console.log( grid );
                    //console.log( checkValidLocation( effectiveRange, grid ) );
//                    if( checkValidLocation( effectiveRange, grid ) ) effectiveList.push( grid.clone().getGeometry().getCoordinates() );
	            	console.log( grid.clone().getGeometry().getCoordinates() );
                });
                console.log( effectiveList );
                
                $.each( effectiveList, function( idx, item ) {
//                	console.log( item )
                  if (idx == 0 ) effectiveRage = item; 
                  if( idx > 0 ) {
//                    effectiveRage = turf.union(effectiveRange, turf.polygon( item ))
                  }
                });
                /*
                let features = $.each(effectiveList, function( idx, coords) {
                    turf.polygon(coords, {combine: 'yes'});
                });
                console.log( features );
                */
                /**
                 * 방법 1.
                 * 주변 객체들을 turf.polygonToLine()으로 line으로 받는다.
                 * 중복된 line은 둘다 삭제한다.
                 * 남는 라인으로 polygon을 만든다.
                 * 
                 * 방법 2.
                 * 
                 */
                  
                
            }
            
            var format = new ol.format.WKT();
            var src = 'EPSG:3857';
            var dest = 'EPSG:4326';
            smallArea.getGeometry().transform(src, dest);
            var wkt = format.writeFeature(smallArea);
            console.log(wkt);
            
            map.removeInteraction(draw);
            map.removeInteraction(snap);
            
            // [1] -------------------------------------------------------------------------------- 소광구 등록
            $.ajax({
            	type: 'POST',
                url: '/area/insertArea.do',
                data: {
                	"tbareaName":$('#smallMineAreaName').val(),
                	"tbareaCategory": "소광구",
                	"tbareaType":"Polygon",
                	"tbareaGeom": String(wkt),
                	"tbareaSmall": (bigAreaId == null ? 0 : bigAreaId )
                },
                success: function(data) {
                    var resultData = JSON.parse(data);
                    console.log("소광구 등록 완료 --------------------");
                    console.log(resultData);
                    console.log("------------------------------------");
                },
                error: function(req, status, err) {
                    console.log(req);
                    console.log(status);
                    console.log(err);
                },
                fail: function(data) {
                    console.log(data);
                }
            });
            
            console.groupEnd('Small Area Draw End');
        });
    }
    addInteractions();
});


//	인자로 받은 Feature의 좌표값으로 buffer()거친 Feature를 리턴.
const createEffectiveRangeByBuffer = function(mineLot, _dist, _unit) {
    console.group('createEffectiveRangeByBuffer()');

    mineLot.getGeometry().transform('EPSG:3857', 'EPSG:4326');
    let coordinates = mineLot.getGeometry().getCoordinates();
    let poly = turf.polygon(coordinates);
  
    let bufferedFeature = turf.buffer(poly, _dist, { steps: 1, units: _unit,});
  
    console.log( bufferedFeature );
    console.log( 'bufferedFeature to Polygon' )
    // bufferedFeature = turf.bbox(bufferedFeature);
    // bufferedFeature = turf.bboxPolygon(bufferedFeature);
    // console.log( bufferedFeature )
  
    let effectiveRange = new ol.format.GeoJSON().readFeatures(bufferedFeature);
    effectiveRange = effectiveRange[0];
    
    effectiveRange.getGeometry().transform('EPSG:4326', 'EPSG:3857');
    mineLot.getGeometry().transform('EPSG:4326', 'EPSG:3857');
  
    console.groupEnd('createEffectiveRangeByBuffer()');
    return effectiveRange;
};  //  createEffectiveRangeByBuffer



/**
 * 두 폴리곤이 겹쳐있는지 확인하기 위한 함수...
 * @param {*} datumArea       : 기준 폴리곤 (feature)
 * @param {*} comparisonArea  : 비교 대상 폴리곤 (feature)
 */
const checkValidLocation = function( datumArea, comparisonArea ) {
    console.group( 'checkValidLocation' );
    console.groupEnd( 'checkValidLocation' );
    return !turf.booleanDisjoint(
      turf.polygon( datumArea.getGeometry().getCoordinates() )
    , turf.polygon( comparisonArea.getGeometry().getCoordinates() )
    );
  }
  
  
/**
 * 준 폴리곤 밖깥으로 나간 대상 폴리곤의 부분을 trim한 뒤 겹치는 영역만 리턴한다.
 * @param {*} datumArea       : 기준 폴리곤 (feature)
 * @param {*} comparisonArea  : 비교 대상 폴리곤 (feature)
 */
const trimPolygon = function( datumArea, comparisonArea ) {
    console.group( 'trimPolygon' );
    
    if( datumArea.getGeometry().getCoordinates() == null || comparisonArea.getGeometry().getCoordinates() == null ) {
    	alert("알수 없는 값이 들어왔 습니다.\n영역을 확인 해 주세요");
    	return null;
    }
    
    console.log( 'datumArea' );
    console.log( datumArea );
    datumArea = turf.polygon( datumArea.getGeometry().getCoordinates() );
    
    console.log( 'comparisonArea' );
    console.log( comparisonArea );
    comparisonArea = turf.polygon( comparisonArea.getGeometry().getCoordinates() );

    comparisonArea = turf.intersect( datumArea, comparisonArea );

//    let rw = new ol.format.GeoJSON();
    console.groupEnd( 'trimPolygon' );

    return rw.readFeature( comparisonArea );
}




// GeoServer에서 환경조사 레이어 wms 불러와 담아놓음
// var wmsSource = new ol.source.TileWMS({
//     url: GEOSERVER_URL + 'wms',
//     params: {
//         'LAYERS': '	environment:environment',
//         'TILED': false,
//     },
//     serverType: 'geoserver',
//     projection: 'EPSG:4326',
//     transition: 0,
//     crossOrigin: "anonymous"
// });

// var wmsLayer = new ol.layer.Tile({
//     source: wmsSource,
//     crossOrigin: "anonymous"
// });





// 환경조사 샘플
$(document).on('click', '#environTest', function () {
    if(!$(this).hasClass('selected')) {
        $(this).addClass('selected');
        $('#environment-table').css({"transform":"translateY(0)"});
        $('#environment').css({"transform":"translateX(0)", "opacity":"1"});

        map.addLayer(wmsLayer);
    } else {
        map.removeLayer(wmsLayer);
        $(this).removeClass('selected');
        $('#environment-table').css({"transform":"translateY(300px)"});
        $('#environment').css({"transform":"translateX(400px)", "opacity":"0"});
    }

    var turfStyle = new ol.style.Style({
        fill: new ol.style.Fill({
            color: '#5858582d'
        }),
        stroke: new ol.style.Stroke({
            color: '#424242',
            width: 10
        }),
        image: new ol.style.Circle({
            radius: 3,
            fill: new ol.style.Fill({
                color: '#2b2b2b70'
            })
        }),
    });

    // convert to a turf.js feature
    var turfLine = turf.lineString([[127.948, 34], [128.778,34]]);
    var turfLine2 = turf.lineString([[127.948, 34.2], [128.778, 34.2]]);

    // show a marker every 200 meters
    var distance = 0.2;

    // get the line length in kilometers
    var length = turf.length(turfLine, {units: 'miles'});
    //console.log(length);

    for (var i = 1; i <= length / distance; i++) {
        var turfPoint = turf.along(turfLine, i * distance, {units: 'miles'});
        var turfPoint2 = turf.along(turfLine2, i * distance, {units: 'miles'});
        //console.log(turfPoint);
        // convert the generated point to a OpenLayers feature
        //console.log(turfPoint.getGeometry());
        //var marker = turfPoint;
        //marker.getGeometry().transform('EPSG:4326', 'EPSG:3857');
        //marker.setStyle(turfStyle);
        var geom = new ol.format.GeoJSON().readFeatures(turfPoint);
        var geom2 = new ol.format.GeoJSON().readFeatures(turfPoint2);

        geom[0].getGeometry().transform('EPSG:4326', 'EPSG:3857');
        geom2[0].getGeometry().transform('EPSG:4326', 'EPSG:3857');

        var tuftStyle = new ol.style.Style({
            fill: new ol.style.Fill({
                color: '#5858582d'
            }),
            stroke: new ol.style.Stroke({
                color: '#ffffff',
                width: 5
            }),
            image: new ol.style.Circle({
                radius: 3,
                fill: new ol.style.Fill({
                    color: '#ffffff'
                })
            })
        });

        geom[0].setStyle(tuftStyle);
        geom2[0].setStyle(tuftStyle);
        environmentSource.addFeature(geom[0]);
        environmentSource.addFeature(geom2[0]);
    }
    environmentVector.setZIndex(10);
    //map.addLayer(environmentVector);
});







// var wmsSource4 = new ol.source.TileWMS({
//     url: 'http://118.220.143.150:8081/geoserver/wms',
//     params: {
//         'LAYERS': 'port:port',
//         'TILED': false,
//     },
//     serverType: 'geoserver',
//     projection: 'EPSG:4326',
//     transition: 0,
//     crossOrigin: "anonymous"
// });

// var wmsLayer4 = new ol.layer.Tile({
//     source: wmsSource4,
//     crossOrigin: "anonymous"
// });

// map.addLayer(wmsLayer4);


/*var wmsSource5 = new ol.source.TileWMS({
    url: GEOSERVER_URL + 'wms',
    params: {
        'LAYERS': 'grid:grid',
        'TILED': false,
    },
    serverType: 'geoserver',
    
    projection: 'EPSG:4326',
    transition: 0,
    crossOrigin: "anonymous"
});

var wmsLayer5 = new ol.layer.Tile({
    source: wmsSource5,
    crossOrigin: "anonymous"
});

map.addLayer(wmsLayer5);*/



// 환경조사 샘플 -------------------------------------------------------------------------
$(document).on('click', '#environTest2', function () {
    if(!$(this).hasClass('selected')) {
        $(this).addClass('selected');
        $('#environment-table').css({"transform":"translateY(0)"});
        $('#environment').css({"transform":"translateX(0)", "opacity":"1"});

        map.addLayer(wmsLayer2);
    } else {
        map.removeLayer(wmsLayer2);
        $(this).removeClass('selected');
        $('#environment-table').css({"transform":"translateY(300px)"});
        $('#environment').css({"transform":"translateX(400px)", "opacity":"0"});
    }
});


// 항적조회 테스트
function fn_track() {
    $.ajax({
        type: "POST",
        url:  'selectTrack.do',
        //data: {"tbship_mmsi": mmsi},
        dataType: 'JSON',
        success: function(data) {
        	var returnData = JSON.parse(data);
        	
        	if(returnData.result === 'true') {
        		var trackData = returnData.track;
        		var arrPoints = [];
                
                var format = new ol.format.WKT();
                
                $.each(trackData, function(idx, item) {
                    // if(idx < 100) {
                    //     arrPoints[idx] = ol.proj.fromLonLat([dataResult[idx].TBTRACK_LONG, dataResult[idx].TBTRACK_LAT], 'EPSG:3857', 'EPSG:4326');
                    // }
                    var src = 'EPSG:3857';
                    var dest = 'EPSG:4326';
                    var wkt = format.readFeature(item.tbtrack_geom);
                    arrPoints[idx] = new ol.proj.fromLonLat(wkt.getGeometry().getCoordinates(), 'EPSG:3857', 'EPSG:4326');
                    console.log(arrPoints[idx]);
                });

                var start, end;
                var dx, dy;
                var rotation;

                $.each(arrPoints, function(i) {
                    if(i+1 < arrPoints.length) {
                        start = arrPoints[i];
                        end = arrPoints[i+1];

                        dx = end[0] - start[0];
                        dy = end[1] - start[1];
                        rotation = Math.atan2(dy, dx);

                        var a = new ol.Feature({
                            geometry: new ol.geom.Point(end)
                        });
            
                        var b = new ol.style.Style({
                            fill: new ol.style.Fill({
                                color: '#d31c04'
                            }),
                            stroke: new ol.style.Stroke({
                                color: '#d31c04',
                                width: 2,
                                lineDash: [4, 8],
                                lineDashOffset: 6
                            }),
                            image: new ol.style.Icon(({
                                anchor: [0.5, 0.5],
                                anchorOrigin: 'top-left',
                                offset: [0, 0],
                                scale: 0.2,
                                opacity: 1,
                                rotateWithView: false,
                                rotation: -rotation,
                                src: 'images/navi.png',
                            }))
                        });
            
                        a.setStyle(b);
                        source.addFeature(a);
                    }
                });

                
                var trackTempFeature = new ol.Feature({
                    geometry: new ol.geom.LineString(arrPoints)
                });
                
                var trackStyle = new ol.style.Style({
                    fill: new ol.style.Fill({
                        color: '#d31c04'
                    }),
                    stroke: new ol.style.Stroke({
                        color: '#000',
                        width: 2,
                        lineDash: [4, 8],
                        lineDashOffset: 6
                    }),
                    image: new ol.style.Icon(({
                        anchor: [0.5, 0.5],
                        anchorOrigin: 'top-left',
                        offset: [0, 0],
                        scale: 1,
                        opacity: 1,
                        rotateWithView: false,
                        rotation: -rotation,
                        src: 'images/navi.png',
                    }))
                });

                trackTempFeature.setStyle(trackStyle);
                source.addFeature(trackTempFeature);
        	} else {
        		alert('조회된 데이터가 없습니다.');
        	}
        	
        	

            // var thisPointStyle = new ol.style.Style({
                // fill: new ol.style.Fill({
                //      color: '#424242'
                // }),
                // stroke: new ol.style.Stroke({
                //     color: '#1ea8caf3',
                //     width: 2,
                //     lineDash: [4, 8],
                //     lineDashOffset: 6
                // }),
                // image: new ol.style.Circle({
                //     radius: 5,
                //     fill: new ol.style.Fill({
                //         color: '#424242'
                //     })
                // }),
            // });
            // trackFeature.setStyle( thisPointStyle );
            // source.addFeature( trackFeature );
            

        },
        error: function(res, sts, err) {
            console.err("err", err);
        }
    });
}