var CONTEXTROOT = $('#contextPath').val();

// 홈화면, 이전화면을 위한 배열 ---------------------------------------------
var movePosition = [];
var favoriteList = [];

// 레이어
var raster = new ol.layer.Tile({
    source: new ol.source.OSM({
//    	url: 'http://xdworld.vworld.kr:8080/2d/Base/service/{z}/{x}/{y}.png',
    	url: 'http://127.0.0.1:3000/tiles/{z}/{x}/{y}.png',
        crossOrigin: "anonymous"
    }),
    crossOrigin: "anonymous"
});

/* 가상선박 소스, 레이어 */
let virtualSource = new ol.source.Vector({
    wrapX: false,
    crossOrigin: "anonymous"
});
let virtualLayer = new ol.layer.Vector({
    source: virtualSource,
    crossOrigin: "anonymous"
});

// 환경조사 데이터 표출 레이어
var environmentSource = new ol.source.Vector({
    crossOrigin: "anonymous"
});
var environmentVector = new ol.layer.Vector({
    source: environmentSource,
    crossOrigin: "anonymous"
});

var source = new ol.source.Vector({
    crossOrigin: "anonymous"
});
var vector = new ol.layer.Vector({
    crossOrigin: "anonymous",
    source: source,
    style: function (feature, resolution) {
        return new ol.style.Style({
            fill: new ol.style.Fill({
                color: '#415a9ee0'
            }),
            stroke: new ol.style.Stroke({
                color: '#464646e8',
                width: 2,
                lineDash: [4, 8],
                lineDashOffset: 6
            }),
            image: new ol.style.Circle({
                radius: 3,
                fill: new ol.style.Fill({
                    color: '#2b2b2b70'
                })
            }),
            text: new ol.style.Text({
                text: '',
                fill: new ol.style.Fill({
                    color: '#464646e8'
                }),
                font: '14px sans-serif'
            })
        });
    }
});


var overlayPopup;
var overlayPopupElement;

var samllSource = new ol.source.Vector({
    crossOrigin: "anonymous"
});
var smallVector = new ol.layer.Vector({
    source: samllSource,
    style: function (feature, resolution) {
        return new ol.style.Style({
            fill: new ol.style.Fill({
                color: '#80ce38a8'
            }),
            stroke: new ol.style.Stroke({
                color: '#7ec43d',
                width: 2,
                lineDash: [4, 8],
                lineDashOffset: 6
            }),
            image: new ol.style.Circle({
                radius: 7,
                fill: new ol.style.Fill({
                    color: '#669c336e'
                })
            }),
            text: new ol.style.Text({
                text: '소광구',
                fill: new ol.style.Fill({
                    color: '#FFFFFF'
                }),
                font: '14px sans-serif'
            })
        });
    },
    crossOrigin: "anonymous"
});

var style = new ol.style.Style({
    fill: new ol.style.Fill({
        color: '#e7e7e71a'
    }),
    stroke: new ol.style.Stroke({
        color: '#494949',
        width: 2
    }),
    image: new ol.style.Circle({
        radius: 7,
        fill: new ol.style.Fill({
            color: '#ffcc33'
        })
    }),
    text: new ol.style.Text({
        text: $('#areaSmallName').val(),
        fill: new ol.style.Fill({
            color: '#5422c9'
        }),
        font: '16px sans-serif'
    })
});

var gridStyle = new ol.style.Style({
    fill: new ol.style.Fill({
        color: 'rgba(255, 255, 255, 0)'
    }),
    stroke: new ol.style.Stroke({
        color: '#818181',
        width: 1
    })
});

var bigStyle = new ol.style.Style({
    fill: new ol.style.Fill({
        color: 'rgba(212, 37, 37, 0.835)'
    }),
    stroke: new ol.style.Stroke({
        color: '#b43939',
        width: 2
    }),
    text: new ol.style.Text({
        text: '',
        fill: new ol.style.Fill({
            color: '#ffffff'
        }),
        font: '14px sans-serif'
    })
});

var selectStyle = new ol.style.Style({
    fill: new ol.style.Fill({
        color: '#bb2121c7'
    }),
    stroke: new ol.style.Stroke({
        color: '#bb2121',
        width: 2
    }),
    text: new ol.style.Text({
        text: 'Selected',
        fill: new ol.style.Fill({
            color: '#ffffff'
        }),
        font: '14px sans-serif'
    })
});



// 기본맵 불러오기 (Default Map) -------------------------------------------------------
var map = new ol.Map({
    target: 'map',
    autoPan: false,
    layers: [
        raster, 
        vector, 
        smallVector,
        virtualLayer
        //osmTile, grildTile, highlightLayer
        ],
    view: new ol.View({
        center: ol.proj.fromLonLat([127, 34.7]),
        zoom: 9,
    }),
    crossOrigin: "anonymous"
});


let objSource = new ol.source.Vector({
    wrapX: false,
    crossOrigin: "anonymous"
});
let objVector = new ol.layer.Vector({
  source: objSource,
  style: new ol.style.Style({
    fill: new ol.style.Fill({
      color: 'rgba(255, 255, 255, 0.1)'
    }),
    stroke: new ol.style.Stroke({
      color: '#000000',
      width: 2
    }),
    image: new ol.style.Circle({
      radius: 7,
      fill: new ol.style.Fill({
        color: '#ffcc33'
      })
    }),
    text: new ol.style.Text({
      font: '12px Verdana',
      scale: 3,
      text: '',
    })
  }),
  crossOrigin: "anonymous"
});

map.addLayer(objVector);

let measureSource = new ol.source.Vector({
    wrapX: false,
    crossOrigin: "anonymous"
});
let measureVector = new ol.layer.Vector({
  source: measureSource,
  crossOrigin: "anonymous"
});



/*
    var gridTile = new ol.layer.Graticule({
        strokeStyle: new ol.style.Stroke({
            color: '#000',
            width: 1,
            lineDash: [0.5, 2]
        }),
        targetSize: 256,
        showLabels: true,
        wrapX: false
    })

    map.addLayer(gridTile);

    map.on('click', function(e){
        console.log(e);
    });
*/



/* 그리드 레이어

	const grid = new ol.source.OSM().getTileGrid({
	  tileSize:[256, 256]
	});

	var grildTile = new ol.layer.Tile({
	  source: new ol.source.TileDebug({
	    tileGrid: grid,
	    projection:'EPSG:4326'
	  })
	});

	const highlightVector = new ol.source.Vector();
	const highlightLayer = new ol.layer.Vector({
	  source: highlightVector,
	  style: new ol.style.Style({
	    stroke: new ol.style.Stroke({
	      width: 3,
	      color: [255, 0, 0, 1]
	    })
	  })
	});

	map.addLayer(grildTile);
	map.addLayer(highlightLayer);


	map.on('singleclick',function(event){
		console.log(event.target);
        var z = map.getView().getZoom();
        var coord = grid.getTileCoordForCoordAndZ(event.coordinate, z);
        var extent = grid.getTileCoordExtent(coord);

        highlightVector.clear();
        highlightVector.addFeature(new ol.Feature({
            geometry: new ol.geom.LineString([
            [ extent[0],extent[1] ],
            [ extent[0],extent[3] ],
            [ extent[2],extent[3] ],
            [ extent[2],extent[1] ],
            [ extent[0],extent[1] ],
            ])
        }));
    });
    
    map.on('singleclick',function(event){
        var z = map.getView().getZoom();
        var coord = grid.getTileCoordForCoordAndZ(event.coordinate, z);
        var extent = grid.getTileCoordExtent(coord);

        highlightVector.clear();
        highlightVector.addFeature(new ol.Feature({
        geometry: new ol.geom.LineString([
            [ extent[0],extent[1] ],
            [ extent[0],extent[3] ],
            [ extent[2],extent[3] ],
            [ extent[2],extent[1] ],
            [ extent[0],extent[1] ],
        ])
        }));
    });
*/


/* 가상선박 체크 */
function fn_virtualShipFeature() {
    var virtualShips = JSON.parse(localStorage.getItem('virtual-ship'));
    virtualSource.clear();
    if(virtualShips !== null) {
        $.each(virtualShips, function(idx) {
            if(virtualShips[idx].shipHide === 'false') {
                var virtualFeature = new ol.Feature({
                    geometry: new ol.geom.Point([Number(virtualShips[idx].shipLat), Number(virtualShips[idx].shipLon)])
                });
    
                var virtualStyle = new ol.style.Style({
                    fill: new ol.style.Fill({
                        color: '#d31c04'
                    }),
                    stroke: new ol.style.Stroke({
                        color: '#d31c04',
                        width: 2,
                        lineDash: [4, 8],
                        lineDashOffset: 6
                    }),
                    image: new ol.style.Icon(({
                        anchor: [0.5, 0.5],
                        anchorOrigin: 'top-left',
                        offset: [0, 0],
                        scale: 1,
                        opacity: 1,
                        rotateWithView: false,
                        src: 'images/vessel/vessel_red.png',
                    }))
                });
    
                virtualFeature.setStyle(virtualStyle);
                virtualSource.addFeature(virtualFeature);
                
            }
        });
    }
}

fn_virtualShipFeature();




// Feature Select 이벤트 추가 -----------------------------------------------------------
var selectClick = new ol.interaction.Select({
    condition: ol.events.condition.click
});
map.addInteraction(selectClick);
    





// 화면이동 완료 후, 현재 좌표값 저장하기 ------------------------------------------------------
map.on('moveend', function() {
    if(movePosition.length === undefined) {
        movePosition[0] = map.getView().getCenter();        	        		
    } else {
        movePosition[movePosition.length] = map.getView().getCenter();
    }
});




// GeoServer Layer 불러오기 --------------------------------------------------------------
// var wmsSource = new ol.source.Vector({
//     format: new ol.format.GeoJSON(),
//     url: 'http://localhost:8800/geoserver/wfs?service=WFS&' +
//             'version=1.0.0&request=GetFeature&typename=test:area&' +
//             'outputFormat=application/json&srsname=EPSG:4326'
// });

// var wmsLayer = new ol.layer.Vector({
//     source: wmsSource
// });

// var wmsSource2 = new ol.source.TileWMS({
//     url: 'http://localhost:8800/geoserver/wms',
//     params: {
//         'LAYERS': 'test:gmt_area',
//         'TILED': false,
//     },
//     serverType: 'geoserver',
//     projection: 'EPSG:4326',
//     transition: 0
// });

// var wmsLayer2 = new ol.layer.Tile({
//     source: wmsSource2
// });

// map.addLayer(wmsLayer);
// map.addLayer(wmsLayer2);





// 지도 스케일 바 표출 -------------------------------------------------------------------
var control = new ol.control.ScaleLine({
    units: 'metric',
    bar: true,
    steps: 1,
    minWidth: 90
  });

map.addControl(control);




// 현재 마우스 포지션 -------------------------------------------------------------------
map.on('pointermove', function(evt) {
    var lonlat = evt.coordinate;
    var lon = lonlat[0].toFixed(5);
    var lat = lonlat[1].toFixed(5);

    var hdms = ol.coordinate.toStringHDMS(ol.proj.transform(lonlat, 'EPSG:3857', 'EPSG:4326'));

    //$('#curPos').html('Lon : ' + lon + '　Lat : ' + lat);
    $('#curPos').html(hdms);
});







// 격자 그리기 --------------------------------------------------------------------------
$(document).on('click', '#setArea', function () {
    // 그리기 기능과 스냅(자석) 기능을 사용을 위해 변수 선언
    var draw, snap; // global so we can remove them later
    // 그리고 난뒤 담을 FeatureCollection 생성
    var featureCollection = new ol.Collection();
    var geometryFunction, maxPoints;

    // 그리기 함수
    function addInteractions() {
        // 사각형을 그리기 위해 2개의 포인트를 이용하여 그림
        maxPoints = 2;
        //geometryFunction = ol.interaction.Draw.createRegularPolygon(4);

        geometryFunction = function (coordinates, geometry) {
            if (!geometry) {
                geometry = new ol.geom.Polygon(null);
            }
            var start = coordinates[0];
            var end = coordinates[1];
            geometry.setCoordinates([
                [start, [start[0], end[1]], end, [end[0], start[1]], start]
            ]);
            return geometry;
        };
        
        // Draw 객체 생성
        draw = new ol.interaction.Draw({
            source: vector.getSource(),
            type: 'LineString',
            geometryFunction: geometryFunction,
            maxPoints: maxPoints,
            features: featureCollection
        });

        // Map에 Draw 이벤트를 포함시킴
        map.addInteraction(draw);


        // 스냅객체 생성 및 맵에 추가
        snap = new ol.interaction.Snap({
            source: source,
            pixelTolerance: 25
        });
        //map.addInteraction(snap);

        // Draw가 시작되고 난 뒤 이벤트 콜백
        draw.on('drawstart', function (evt) {
            var sketch = evt.feature;

            //console.log(sketch.getGeometry());
            sketch.getGeometry().on('change', function (evt) {
                var geom = evt.target;
                console.log(geom.getLastCoordinate());
                var coord = geom.getLastCoordinate();
                var output;
                output = formatLength(geom);
                overlayPopupElement.innerHTML = output;
                overlayPopup.setPosition(geom.getLastCoordinate());
            });
            //evt.feature.setId('id');
            evt.feature.setProperties({
                'category': 'bigArea'
            });
        });

        // 맵에 Feature Select 이벤트를 추가
        map.addInteraction(selectClick);

        // Draw가 끝나고 나면 실행 될 이벤트 콜백
        draw.on('drawend', function (e) {
            // 그리기가 끝나고 난 후 방금 그린 Feature를 담아둠
            var currentFeature = e.feature;
            console.log(currentFeature.getGeometry().getCoordinates());

            // 위 Feature의 Coordinates 값을 담음
            var coordinates = currentFeature.getGeometry().getCoordinates();
            var coordinate = coordinates[0];
            //console.log(coordinate[0]);

            var point1_X = coordinate[0][0];
            var point1_Y = coordinate[0][1];

            var point2_X = coordinate[1][0];
            var point2_Y = coordinate[1][1];

            var point3_X = coordinate[2][0];
            var point3_Y = coordinate[2][1];

            var point4_X = coordinate[3][0];
            var point4_Y = coordinate[3][1];

            // 가로 값
            var g = [];
            // 세로 값
            var s = [];

            var g1, g2;
            var s1, s2;

            for (var i = 0; i <= 12; i++) {
                if (i == 0) {
                    g1 = point1_X;
                    g[i] = g1;
                } else {
                    g2 = (point4_X - point1_X) / 12;

                    g[i] = g1 + g2;

                    g1 = g[i];
                }
            }

            for (var i = 0; i <= 12; i++) {
                if (i == 0) {
                    s1 = point1_Y;
                    s[i] = s1;
                } else {
                    s2 = (point2_Y - point1_Y) / 12;

                    s[i] = s1 + s2;

                    s1 = s[i];
                }
            }


            var test = [];
            var num = 0;

            $.each(s, function (j) {
                $.each(g, function (i) {
                    if (num == 0) {
                        test[num] = [
                            [
                                [g[i], s[j]],
                                [g[i], s[j + 1]],
                                [g[i + 1], s[j + 1]],
                                [g[i + 1], s[j]],
                                [g[i], s[j]]
                            ]
                        ];
                        num++;
                    } else if (num != (g.length * s.length)) {
                        if ((i + 1) <= g.length - 1 && (j + 1) <= s.length - 1) {
                            //console.log("들어왔니");
                            test[num] = [
                                [
                                    [g[i], s[j]],
                                    [g[i], s[j + 1]],
                                    [g[i + 1], s[j + 1]],
                                    [g[i + 1], s[j]],
                                    [g[i], s[j]]
                                ]
                            ];
                            num++;
                        }

                    } else {
                        console.log("ccc");
                    }
                });
            });

            console.log(test);
            console.log(test.length);

            $.each(test, function (idx, item) {
                if (idx < test.length) {
                    var testFeature = new ol.Feature({
                        geometry: new ol.geom.Polygon(test[idx])
                    });

                    var myStyle = new ol.style.Style({
                        text: new ol.style.Text({
                            text: idx,
                            fill: new ol.style.Fill({
                                color: '#3f3f3f'
                            }),
                            font: '13px sans-serif'
                        })
                    });

                    vector.getSource().addFeature(testFeature);

                    var format = new ol.format.WKT();
                    var src = 'EPSG:3857';
                    var dest = 'EPSG:4326';
                    var wkt = format.writeGeometry(testFeature.getGeometry().transform(src, dest));

                    // $.ajax({
                    //     type: 'POST',
                    //     url: '/WebVMS_Test/insertEnvironment.do',
                    //     data: {"type": "Polygon", "geom": String(wkt)},
                    //     dataType: 'text',
                    //     success: function(data) {
                    //         console.log(data);
                    //     },
                    //     error: function(req, status, err) {
                    //         console.log(req);
                    //         console.log(status);
                    //         console.log(err);
                    //     },
                    //     fail: function(data) {
                    //         console.log(data);
                    //     }
                    // });
                }
            });

            map.removeInteraction(draw);
            map.removeInteraction(snap);
        });

    }
    addInteractions();
});



// 대광구 생성 (그리기툴) ---------------------------------------------------------------------------------
$(document).on('click', '#setBigAreaDraw', function () {
        var draw, snap; // global so we can remove them later
        var featureCollection = new ol.Collection();
        var drawFeature = new ol.Feature({});

        function addInteractions() {
            draw = new ol.interaction.Draw({
                source: vector.getSource(),
                type: 'Polygon',
                features: featureCollection
            });

            map.addInteraction(draw);

            snap = new ol.interaction.Snap({
                source: source
            });

            //map.addInteraction(snap);
            map.addInteraction(selectClick);

            draw.on('drawend', function (e) {
                var currentFeature = e.feature;
                //console.log(currentFeature);
                //source.addFeature(currentFeature);
                console.log(currentFeature.getGeometry().getCoordinates());
                var coord = currentFeature.getGeometry().getCoordinates()[0];
                var resultPoint1, resultPoint2, resultPoint3, resultPoint4;
                var resultArr;
                
                // 비교할 대상 첫 포인트 담아두고 최대값 X,Y 갱신
                var x = coord[0][0];
                var y = coord[0][1];

                // 비교할 대상 첫 포인트 담아두고 최소값 X,Y 갱신
                var minX = coord[0][0];
                var minY = coord[0][1];
        
                // 비교하여 최대, 최소 X, Y 값 담기
                $.each(coord, function(idx) {
                    //console.log("Coordinate 길이 : " + coord.length);
                    if(idx !== 0) {
                        // X 최대값 갱신
                        if(x < coord[idx][0]) {
                            x = coord[idx][0];
                        }
                        if(coord[idx][0] < minX) {
                            minX = coord[idx][0];
                        }
                        // Y 최대값 갱신
                        if(y < coord[idx][1]) {
                            y = coord[idx][1];
                        }
                        if(coord[idx][1] < minY) {
                            minY = coord[idx][1];
                        }
                    }
                });
            
                console.log("최대 X 값");
                console.log(x);
                console.log("최대 Y 값");
                console.log(y);
                console.log("최소 X 값");
                console.log(minX);
                console.log("최소 Y 값");
                console.log(minY);

                resultPoint1 = [minX, y];   // 상좌
                resultPoint2 = [x, y];   // 상우
                resultPoint3 = [x, minY];   // 하우
                resultPoint4 = [minX, minY];   // 하좌
                resultArr = [resultPoint1, resultPoint2, resultPoint3, resultPoint4, resultPoint1];
                console.log(resultArr);

                var testingFeature = new ol.Feature({
                    geometry: new ol.geom.Polygon([resultArr])
                });

                testingFeature.setStyle(bigStyle);
                vector.getSource().addFeature(testingFeature);

                var areaTextFeature = new ol.Feature({
                    geometry: new ol.geom.Point([(minX + 100), (y + 60)])
                });

                var areaTextStyle = new ol.style.Style({
                    text: new ol.style.Text({
                        text: $('#bigAreaName').val(),
                        fill: new ol.style.Fill({
                            color: '#3f3f3f'
                        }),
                        font: '14px sans-serif',
                        scale: 2
                    })
                });

                areaTextFeature.setStyle(areaTextStyle);
                vector.getSource().addFeature(areaTextFeature);

                console.log(testingFeature.getGeometry().getCoordinates());

                var format = new ol.format.WKT();
                var src = 'EPSG:3857';
                var dest = 'EPSG:4326';
                testingFeature.getGeometry().transform(src, dest);
                var wkt = format.writeFeature(testingFeature);
                console.log(wkt);
                
                /*
                $.ajax({
                    type: 'POST',
                    url: '/WebVMS_Test/insertEnvironment.do',
                    data: {"type": "Polygon", "geom": String(wkt)},
                    dataType: 'text',
                    success: function(data) {
                        console.log(data);
                    },
                    error: function(req, status, err) {
                        console.log(req);
                        console.log(status);
                        console.log(err);
                    },
                    fail: function(data) {
                        console.log(data);
                    }
                });
                */

                var gridDistance = $('#gridDistance').val();

                var point = turf.point(ol.proj.toLonLat([minX, y]));
                var distance = gridDistance/1000;
                var bearing = 90;
                var options = {units: 'kilometers'};

                var destination = turf.destination(point, distance, bearing, options);
                console.log(destination);

                var kiloFeature = new ol.format.GeoJSON().readFeatures(destination);
                kiloFeature[0].getGeometry().transform('EPSG:4326', 'EPSG:3857');

                var kilo = kiloFeature[0].getGeometry().getCoordinates()[0] - minX;
                console.log('최소 X값으로 부터 1키로미터 위치 :: ' + kiloFeature[0].getGeometry().getCoordinates()[0]);
                console.log('시작 포인트 :: ' + minX);
                console.log('1키로 :: ' + kilo);

                // X
                var from = turf.point(ol.proj.toLonLat([minX, y]));
                var to = turf.point(ol.proj.toLonLat([x, y]));

                var resultDistance = turf.distance(from, to, options);

                // Y
                var fromY = turf.point(ol.proj.toLonLat([minX, y]));
                var toY = turf.point(ol.proj.toLonLat([minX, minY]));

                var resultDistanceY = turf.distance(fromY, toY, options);

                
                console.log('minX ~ X 거리 :: ' + resultDistance);
                console.log('거리 (km -> meters) /사용자 입력거리 (가로개수) :: ' + (resultDistance * 1000)/(gridDistance));
                //console.log('거리 (km -> meters) /사용자 입력거리 (가로개수) :: ' + (resultDistance * 1000)/(gridDistance));

                var xCount = Math.ceil((resultDistance * 1000)/(gridDistance));
                var yCount = Math.ceil((resultDistanceY * 1000)/(gridDistance)) + 1;
                console.log(xCount);
                console.log(yCount);
                
                /*
                    TurfJS, squareGrid 사용
                    bbox = minX, minY, maxX, maxY
                    cellSide는 units에 설정된 값에 따른 격자 하나의 크기
                    option = default(kilometers), miles, degrees, radians
                
                    var bbox = [minX, minY, x, y];
                    var cellSide = 150;
                    var optionss = {units: 'kilometers'};

                    var squareGrid = turf.squareGrid(bbox, cellSide, optionss);
                    // 생성된 squareGrid를 Feature로 변환
                    var squareGirdFeature = new ol.format.GeoJSON().readFeatures(squareGrid);
                    console.log(squareGirdFeature);
                    source.addFeatures(squareGirdFeature);
                */
            
                //console.log("결과 배열");
                //console.log(resultArr[0][0]);
                //console.log(resultArr[0][1]);

                // 이제 격자 만들기
                $('#progress').css({"display":"block"});

                var point1_X = resultArr[0][0];
                var point1_Y = resultArr[0][1];

                var point2_X = resultArr[1][0];
                var point2_Y = resultArr[1][1];

                var point3_X = resultArr[2][0];
                var point3_Y = resultArr[2][1];

                var point4_X = resultArr[3][0];
                var point4_Y = resultArr[3][1];

                // 가로 값
                var g = [];
                // 세로 값
                var s = [];

                var g1, g2;
                var s1, s2;

                for (var i = 0; i <= xCount; i++) {
                    if (i == 0) {
                        g1 = point1_X;
                        g[i] = g1;
                    } else {
                        //g2 = (point2_X - point1_X) / kilo;
                        if(g1 <= x) {
                            g2 = kilo;
                            g[i] = g1 + g2;
                            g1 = g[i];
                        } else {
                            g[i] = x;
                            break;
                        }
                    }
                }

                for (var j = 0; j <= yCount; j++) {
                    if (j == 0) {
                        s1 = point1_Y;
                        s[j] = s1;
                    } else {
                        if(s1 > minY) {
                            s2 = kilo;
                            s[j] = s1 - s2;
                            s1 = s[j];
                        } else {
                            s[j] = minY;
                            break;
                        }
                    }
                }

                var test = [];
                var num = 0;

                $.each(s, function (j) {
                    $.each(g, function (i) {
                        if (num == 0) {
                            test[num] = [
                                [
                                    [g[i], s[j]],
                                    [g[i + 1], s[j]],
                                    [g[i + 1], s[j + 1]],
                                    [g[i], s[j + 1]],
                                    [g[i], s[j]]
                                ]
                            ];
                            num++;
                        } else if (num != (g.length * s.length)) {
                            if ((i + 1) <= g.length - 1 && (j + 1) <= s.length -
                                1) {
                                test[num] = [
                                    [
                                        [g[i], s[j]],
                                        [g[i + 1], s[j]],
                                        [g[i + 1], s[j + 1]],
                                        [g[i], s[j + 1]],
                                        [g[i], s[j]]
                                    ]
                                ];
                                num++;
                            }

                        } else {
                            console.log("ccc");
                        }
                    });
                });

                $.each(test, function (idx, item) {
                    if (idx < test.length) {
                        var testFeature = new ol.Feature({
                            geometry: new ol.geom.Polygon(test[idx])
                        });
                        testFeature.setStyle(gridStyle);
                        vector.getSource().addFeature(testFeature);
                    }
                });
                map.removeInteraction(draw);
                $('#progress').css({"display":"none"});
            });
            
        }
        addInteractions();
});


// 대광구 생성 (좌표지정) ---------------------------------------------------------------------------------
function createBigArea() {
    // 상좌
    var lat1 = $('input[name=lat1]').val();
    var lon1 = $('input[name=lon1]').val();
    // 상우
    var lat2 = $('input[name=lat2]').val();
    var lon2 = $('input[name=lon2]').val();
    // 하좌
    var lat3 = $('input[name=lat3]').val();
    var lon3 = $('input[name=lon3]').val();
    // 하우
    var lat4 = $('input[name=lat4]').val();
    var lon4 = $('input[name=lon4]').val();

    if(lat1 === null || lat1 === '') {
        $('#geomValidate').html('<b>"상좌" 위도를 입력해주세요!</b>');
        $('input[name=lat1]').focus();
        return false;
    }
    if(lon1 === null || lon1 === '') {
        $('#geomValidate').html('<b>"상좌" 경도를 입력해주세요!</b>');
        $('input[name=lon1]').focus();
        return false;
    }
    if(lat2 === null || lat2 === '') {
        $('#geomValidate').html('<b>"상우" 위도를 입력해주세요!</b>');
        $('input[name=lat2]').focus();
        return false;
    }
    if(lon2 === null || lon2 === '') {
        $('#geomValidate').html('<b>"상우" 경도를 입력해주세요!</b>');
        $('input[name=lon2]').focus();
        return false;
    }
    if(lat3 === null || lat3 === '') {
        $('#geomValidate').html('<b>"하좌" 위도를 입력해주세요!</b>');
        $('input[name=lat3]').focus();
        return false;
    }
    if(lon3 === null || lon3 === '') {
        $('#geomValidate').html('<b>"하좌" 경도를 입력해주세요!</b>');
        $('input[name=lon3]').focus();
        return false;
    }
    if(lat4 === null || lat4 === '') {
        $('#geomValidate').html('<b>"하우" 위도를 입력해주세요!</b>');
        $('input[name=lat4]').focus();
        return false;
    }
    if(lon4 === null || lon4 === '') {
        $('#geomValidate').html('<b>"하우" 경도를 입력해주세요!</b>');
        $('input[name=lon4]').focus();
        return false;
    }

    var coord = [
        new ol.proj.transform([parseFloat(lat1), parseFloat(lon1)], 'EPSG:4326', 'EPSG:3857'), 
        new ol.proj.transform([parseFloat(lat2), parseFloat(lon2)], 'EPSG:4326', 'EPSG:3857'),
        new ol.proj.transform([parseFloat(lat3), parseFloat(lon3)], 'EPSG:4326', 'EPSG:3857'),
        new ol.proj.transform([parseFloat(lat4), parseFloat(lon4)], 'EPSG:4326', 'EPSG:3857'),
        new ol.proj.transform([parseFloat(lat1), parseFloat(lon1)], 'EPSG:4326', 'EPSG:3857')
    ];
    console.log(coord);

    var resultPoint1, resultPoint2, resultPoint3, resultPoint4;
    var resultArr;

    // 상우 X
    var x = coord[1][0];
    // 상  Y
    var y = coord[0][1];
    // 상좌 X
    var minX = coord[0][0];
    // 하 Y
    var minY = coord[3][1];
    
    console.log("최대 X 값");
    console.log(x);
    console.log("최대 Y 값");
    console.log(y);
    console.log("최소 X 값");
    console.log(minX);
    console.log("최소 Y 값");
    console.log(minY);

    resultPoint1 = [minX, y];   // 상좌
    resultPoint2 = [x, y];   // 상우
    resultPoint3 = [x, minY];   // 하우
    resultPoint4 = [minX, minY];   // 하좌
    resultArr = [resultPoint1, resultPoint2, resultPoint3, resultPoint4, resultPoint1];
    console.log(resultArr);

    var testingFeature = new ol.Feature({
        geometry: new ol.geom.Polygon([resultArr])
    });

    console.log(testingFeature);

    testingFeature.setStyle(bigStyle);
    vector.getSource().addFeature(testingFeature);

    var areaTextFeature = new ol.Feature({
        geometry: new ol.geom.Point([(minX + 100), (y + 60)])
    });

    var areaTextStyle = new ol.style.Style({
        text: new ol.style.Text({
            text: $('#bigAreaGeomName').val(),
            fill: new ol.style.Fill({
                color: '#3f3f3f'
            }),
            font: '14px sans-serif',
            scale: 2
        })
    });

            areaTextFeature.setStyle(areaTextStyle);
            vector.getSource().addFeature(areaTextFeature);

            console.log(testingFeature.getGeometry().getCoordinates());

            var format = new ol.format.WKT();
            var src = 'EPSG:3857';
            var dest = 'EPSG:4326';
            testingFeature.getGeometry().transform(src, dest);
            var wkt = format.writeFeature(testingFeature);
            console.log(wkt);
            
            /*
            $.ajax({
                type: 'POST',
                url: '/WebVMS_Test/insertEnvironment.do',
                data: {"type": "Polygon", "geom": String(wkt)},
                dataType: 'text',
                success: function(data) {
                    console.log(data);
                },
                error: function(req, status, err) {
                    console.log(req);
                    console.log(status);
                    console.log(err);
                },
                fail: function(data) {
                    console.log(data);
                }
            });
            */

            var gridDistance = $('#gridGeomDistance').val();
            console.log(gridDistance);

            var point = turf.point(ol.proj.toLonLat([minX, y]));
            var distance = gridDistance/1000;
            var bearing = 90;
            var options = {units: 'kilometers'};

            var destination = turf.destination(point, distance, bearing, options);
            console.log(destination);

            var kiloFeature = new ol.format.GeoJSON().readFeatures(destination);
            kiloFeature[0].getGeometry().transform('EPSG:4326', 'EPSG:3857');

            var kilo = kiloFeature[0].getGeometry().getCoordinates()[0] - minX;
            console.log('최소 X값으로 부터 1키로미터 위치 :: ' + kiloFeature[0].getGeometry().getCoordinates()[0]);
            console.log('시작 포인트 :: ' + minX);
            console.log('1키로 :: ' + kilo);

            // X
            var from = turf.point(ol.proj.toLonLat([minX, y]));
            var to = turf.point(ol.proj.toLonLat([x, y]));

            var resultDistance = turf.distance(from, to, options);

            // Y
            var fromY = turf.point(ol.proj.toLonLat([minX, y]));
            var toY = turf.point(ol.proj.toLonLat([minX, minY]));

            var resultDistanceY = turf.distance(fromY, toY, options);

            
            console.log('minX ~ X 거리 :: ' + resultDistance);
            console.log('거리 (km -> meters) /사용자 입력거리 (가로개수) :: ' + (resultDistance * 1000)/(gridDistance));
            //console.log('거리 (km -> meters) /사용자 입력거리 (가로개수) :: ' + (resultDistance * 1000)/(gridDistance));

            var xCount = Math.ceil((resultDistance * 1000)/(gridDistance));
            var yCount = Math.ceil((resultDistanceY * 1000)/(gridDistance)) + 1;
            console.log(xCount);
            console.log(yCount);
            
            /*
                TurfJS, squareGrid 사용
                bbox = minX, minY, maxX, maxY
                cellSide는 units에 설정된 값에 따른 격자 하나의 크기
                option = default(kilometers), miles, degrees, radians
            
                var bbox = [minX, minY, x, y];
                var cellSide = 150;
                var optionss = {units: 'kilometers'};

                var squareGrid = turf.squareGrid(bbox, cellSide, optionss);
                // 생성된 squareGrid를 Feature로 변환
                var squareGirdFeature = new ol.format.GeoJSON().readFeatures(squareGrid);
                console.log(squareGirdFeature);
                source.addFeatures(squareGirdFeature);
            */
        
            //console.log("결과 배열");
            //console.log(resultArr[0][0]);
            //console.log(resultArr[0][1]);

            // 이제 격자 만들기
            

            var point1_X = resultArr[0][0];
            var point1_Y = resultArr[0][1];

            var point2_X = resultArr[1][0];
            var point2_Y = resultArr[1][1];

            var point3_X = resultArr[2][0];
            var point3_Y = resultArr[2][1];

            var point4_X = resultArr[3][0];
            var point4_Y = resultArr[3][1];

            // 가로 값
            var g = [];
            // 세로 값
            var s = [];

            var g1, g2;
            var s1, s2;

            for (var i = 0; i <= xCount; i++) {
                if (i == 0) {
                    g1 = point1_X;
                    g[i] = g1;
                } else {
                    //g2 = (point2_X - point1_X) / kilo;
                    if(g1 <= x) {
                        g2 = kilo;
                        g[i] = g1 + g2;
                        g1 = g[i];
                    } else {
                        g[i] = x;
                        break;
                    }
                }
            }

            for (var j = 0; j <= yCount; j++) {
                if (j == 0) {
                    s1 = point1_Y;
                    s[j] = s1;
                } else {
                    if(s1 > minY) {
                        s2 = kilo;
                        s[j] = s1 - s2;
                        s1 = s[j];
                    } else {
                        s[j] = minY;
                        break;
                    }
                }
            }

            var test = [];
            var num = 0;

            $.each(s, function (j) {
                $.each(g, function (i) {
                    if (num == 0) {
                        test[num] = [
                            [
                                [g[i], s[j]],
                                [g[i + 1], s[j]],
                                [g[i + 1], s[j + 1]],
                                [g[i], s[j + 1]],
                                [g[i], s[j]]
                            ]
                        ];
                        num++;
                    } else if (num != (g.length * s.length)) {
                        if ((i + 1) <= g.length - 1 && (j + 1) <= s.length -
                            1) {
                            test[num] = [
                                [
                                    [g[i], s[j]],
                                    [g[i + 1], s[j]],
                                    [g[i + 1], s[j + 1]],
                                    [g[i], s[j + 1]],
                                    [g[i], s[j]]
                                ]
                            ];
                            num++;
                        }

                    } else {
                        console.log("ccc");
                    }
                });
            });

            $.each(test, function (idx, item) {
                if (idx < test.length) {
                    var testFeature = new ol.Feature({
                        geometry: new ol.geom.Polygon(test[idx])
                    });
                    testFeature.setStyle(gridStyle);
                    vector.getSource().addFeature(testFeature);
                }
            });
    
            //$('#progress').css({"display":"none"});
            $('#areaCreatePanel-geom').css({"display":"none"});
}
            

// Feature Select Event ------------------------------------------------------------------------
selectClick.on('select', function (evt) {
  console.group('selectClick.on Select');
    snap = new ol.interaction.Snap({
        source: [source, environmentSource]
    });

    if (evt.selected[0]) {
        console.log("----------------------------------------");
        console.log("---- Selected Feature ID : " + evt.selected[0].getId());
        console.log("---- Selected Feature get Geometry");
        console.log(evt.selected[0].getGeometry());
        console.log("---- Selected Feature get Coordinates");
        console.log(evt.selected[0].getGeometry().getCoordinates());
        console.log("---- Selected Feature get First Coordinate");
        console.log(evt.selected[0].getGeometry().getCoordinates()[0]);
    }

  console.groupEnd('selectClick.on Select');
});


// 소광구 설정 --------------------------------------------------------------------------
$(document).on('click', '#setSmallArea', function () {
    
    let _unit = document.querySelector('input[name=effective_range_unit]:checked').value;
    let _dist = document.getElementById('effective_range_distance').value;
    //  유효범위의 거리 설정이 자유롭긴 하지만 필터링 한번 해줘야 하지 않을까 싶음.
    console.log( _dist + _unit );
    if( !confirm('유효범위의 광구와의 거리는 ' + _dist + ' ' + _unit + '입니다.') ) return;
    
    var draw, snap; // global so we can remove them later

    var featureCollection = new ol.Collection();

    function addInteractions() {
        draw = new ol.interaction.Draw({
            source: samllSource,
            type: 'Polygon',
            features: featureCollection
        });
        map.addInteraction(draw);

        snap = new ol.interaction.Snap({
            source: source
        });
        map.addInteraction(snap);

        draw.on('drawstart', function (evt) {
          console.group('Small Area Draw Start');
             var sketch = evt.feature;
            // sketch.getGeometry().on('change', function (evt) {

            //     map.on('click', function(event) {
            //         console.log('클릭');
            //     });

            //      var geom = evt.target;
            //      var output;
            //      output = formatLength(geom);
            //      overlayPopupElement.innerHTML = output;
            //      overlayPopup.setPosition(geom.getLastCoordinate());
            // });

            //evt.feature.setId('id');
            sketch.setProperties({
                'category': 'smallArea'
            });
          console.groupEnd('Small Area Draw Start');
        });

        /*
        map.on('click', function(event) {
            console.log('클릭');
            console.log(event.coordinate);
            //createMeasureTooltip();
            var geom = event.coordinate;
            var output;
            //output = formatLength(geom);
            overlayPopupElement.innerHTML = output;
            overlayPopup.setPosition(geom.getLastCoordinate());
        });
        */

         

        draw.on('drawend', function (evt) {
            console.group('Small Area Draw End');
            console.log("유효범위 만들기");
            
            evt.feature.setProperties({
                'category': 'Small Area'
            });
            let smallArea = evt.feature;
            

            source.addFeature(createEffectiveRangeByBuffer(smallArea, _dist, _unit));

            // map.addInteraction(selectClick);
            map.removeInteraction(draw);
            map.removeInteraction(snap);
            console.groupEnd('Small Area Draw End');
        });
    }
    addInteractions();
});


//	인자로 받은 Feature의 좌표값으로 buffer()거친 Feature를 리턴.
const createEffectiveRangeByBuffer = function(mineLot, _dist, _unit) {
    console.group('createEffectiveRangeByBuffer()');

    mineLot.getGeometry().transform('EPSG:3857', 'EPSG:4326');
    let coordinates = mineLot.getGeometry().getCoordinates();
    let poly = turf.buffer( turf.polygon(coordinates), _dist, {units: _unit});

    let effectiveRange = new ol.format.GeoJSON().readFeatures(poly);
    console.log('effectiveRange : ');
    // console.log(effectiveRange[0]);

    effectiveRange[0].setStyle( new ol.style.Style({
        stroke: new ol.style.Stroke({
          color: 'red',
          lineDash: [3, 10],
          width: 2
        })
    }));

    effectiveRange[0].getGeometry().transform('EPSG:4326', 'EPSG:3857');
    mineLot.getGeometry().transform('EPSG:4326', 'EPSG:3857');

    effectiveRange[0].setProperties({
        'category' : 'Effective Range'
    });

    console.groupEnd('createEffectiveRangeByBuffer()');
    return effectiveRange[0];
};  //  createEffectiveRangeByBuffer



// GeoServer에서 환경조사 레이어 wms 불러와 담아놓음
var wmsSource = new ol.source.TileWMS({
    url: 'http://118.220.143.150:8081/geoserver/wms',
    params: {
        'LAYERS': '	environment:environment',
        'TILED': false,
    },
    serverType: 'geoserver',
    projection: 'EPSG:4326',
    transition: 0,
    crossOrigin: "anonymous"
});

var wmsLayer = new ol.layer.Tile({
    source: wmsSource,
    crossOrigin: "anonymous"
});





// 환경조사 샘플
$(document).on('click', '#environTest', function () {
    if(!$(this).hasClass('selected')) {
        $(this).addClass('selected');
        $('#environment-table').css({"transform":"translateY(0)"});
        $('#environment').css({"transform":"translateX(0)", "opacity":"1"});

        map.addLayer(wmsLayer);
    } else {
        map.removeLayer(wmsLayer);
        $(this).removeClass('selected');
        $('#environment-table').css({"transform":"translateY(300px)"});
        $('#environment').css({"transform":"translateX(400px)", "opacity":"0"});
    }

    var turfStyle = new ol.style.Style({
        fill: new ol.style.Fill({
            color: '#5858582d'
        }),
        stroke: new ol.style.Stroke({
            color: '#424242',
            width: 10
        }),
        image: new ol.style.Circle({
            radius: 3,
            fill: new ol.style.Fill({
                color: '#2b2b2b70'
            })
        }),
    });

    // convert to a turf.js feature
    var turfLine = turf.lineString([[127.948, 34], [128.778,34]]);
    var turfLine2 = turf.lineString([[127.948, 34.2], [128.778, 34.2]]);

    // show a marker every 200 meters
    var distance = 0.2;

    // get the line length in kilometers
    var length = turf.length(turfLine, {units: 'miles'});
    //console.log(length);

    for (var i = 1; i <= length / distance; i++) {
        var turfPoint = turf.along(turfLine, i * distance, {units: 'miles'});
        var turfPoint2 = turf.along(turfLine2, i * distance, {units: 'miles'});
        //console.log(turfPoint);
        // convert the generated point to a OpenLayers feature
        //console.log(turfPoint.getGeometry());
        //var marker = turfPoint;
        //marker.getGeometry().transform('EPSG:4326', 'EPSG:3857');
        //marker.setStyle(turfStyle);
        var geom = new ol.format.GeoJSON().readFeatures(turfPoint);
        var geom2 = new ol.format.GeoJSON().readFeatures(turfPoint2);

        geom[0].getGeometry().transform('EPSG:4326', 'EPSG:3857');
        geom2[0].getGeometry().transform('EPSG:4326', 'EPSG:3857');

        var tuftStyle = new ol.style.Style({
            fill: new ol.style.Fill({
                color: '#5858582d'
            }),
            stroke: new ol.style.Stroke({
                color: '#ffffff',
                width: 5
            }),
            image: new ol.style.Circle({
                radius: 3,
                fill: new ol.style.Fill({
                    color: '#ffffff'
                })
            })
        });

        geom[0].setStyle(tuftStyle);
        geom2[0].setStyle(tuftStyle);
        environmentSource.addFeature(geom[0]);
        environmentSource.addFeature(geom2[0]);
    }
    environmentVector.setZIndex(10);
    //map.addLayer(environmentVector);
});



// 환경조사 샘플격자 -------------------------------------------------------------------------


var wmsSource3 = new ol.source.TileWMS({
    url: 'http://118.220.143.150:8081/geoserver/wms',
    params: {
        'LAYERS': 'eez:area',
        'TILED': false,
    },
    serverType: 'geoserver',
    projection: 'EPSG:4326',
    transition: 0,
    crossOrigin: "anonymous"
});

var wmsLayer3 = new ol.layer.Tile({
    source: wmsSource3,
    crossOrigin: "anonymous"
});

map.addLayer(wmsLayer3);


// var wmsSource4 = new ol.source.TileWMS({
//     url: 'http://118.220.143.150:8081/geoserver/wms',
//     params: {
//         'LAYERS': 'port:port',
//         'TILED': false,
//     },
//     serverType: 'geoserver',
//     projection: 'EPSG:4326',
//     transition: 0,
//     crossOrigin: "anonymous"
// });

// var wmsLayer4 = new ol.layer.Tile({
//     source: wmsSource4,
//     crossOrigin: "anonymous"
// });

// map.addLayer(wmsLayer4);


var wmsSource5 = new ol.source.TileWMS({
    url: 'http://118.220.143.150:8081/geoserver/wms',
    params: {
        'LAYERS': 'grid:grid',
        'TILED': false,
    },
    serverType: 'geoserver',
    projection: 'EPSG:4326',
    transition: 0,
    crossOrigin: "anonymous"
});

var wmsLayer5 = new ol.layer.Tile({
    source: wmsSource5,
    crossOrigin: "anonymous"
});

map.addLayer(wmsLayer5);



// 환경조사 샘플 -------------------------------------------------------------------------
$(document).on('click', '#environTest2', function () {
    if(!$(this).hasClass('selected')) {
        $(this).addClass('selected');
        $('#environment-table').css({"transform":"translateY(0)"});
        $('#environment').css({"transform":"translateX(0)", "opacity":"1"});

        map.addLayer(wmsLayer2);
    } else {
        map.removeLayer(wmsLayer2);
        $(this).removeClass('selected');
        $('#environment-table').css({"transform":"translateY(300px)"});
        $('#environment').css({"transform":"translateX(400px)", "opacity":"0"});
    }
});


// 항적조회 테스트
function fn_track(mmsi) {
    $.ajax({
        type: "POST",
        url:  'selectTrack.do',
        data: {"MMSI": mmsi},
        dataType: 'text',
        success: function(data) {
            var resultTemp = JSON.parse(data);
            var dataResult = resultTemp.result;

            var arrPoints = [];
            $.each(dataResult, function(idx) {
                if(idx < 100) {
                    arrPoints[idx] = ol.proj.fromLonLat([dataResult[idx].TBTRACK_LONG, dataResult[idx].TBTRACK_LAT], 'EPSG:3857', 'EPSG:4326');
                }
            });

//            console.log(arrPoints);

            var start, end;
            var dx, dy;
            var rotation;

            $.each(arrPoints, function(i) {
                if(i+1 < arrPoints.length) {
                    start = arrPoints[i];
                    end = arrPoints[i+1];

                    dx = end[0] - start[0];
                    dy = end[1] - start[1];
                    rotation = Math.atan2(dy, dx);

                    var a = new ol.Feature({
                        geometry: new ol.geom.Point(end)
                    });
        
                    var b = new ol.style.Style({
                        fill: new ol.style.Fill({
                            color: '#d31c04'
                        }),
                        stroke: new ol.style.Stroke({
                            color: '#d31c04',
                            width: 2,
                            lineDash: [4, 8],
                            lineDashOffset: 6
                        }),
                        image: new ol.style.Icon(({
                            anchor: [0.5, 0.5],
                            anchorOrigin: 'top-left',
                            offset: [0, 0],
                            scale: 1,
                            opacity: 1,
                            rotateWithView: false,
                            rotation: -rotation,
                            src: 'images/navi.png',
                        }))
                    });
        
                    a.setStyle(b);
                    source.addFeature(a);
                }
            });

            
            var trackTempFeature = new ol.Feature({
                geometry: new ol.geom.LineString(arrPoints)
            });
            
            var trackStyle = new ol.style.Style({
                fill: new ol.style.Fill({
                    color: '#d31c04'
                }),
                stroke: new ol.style.Stroke({
                    color: '#000',
                    width: 2,
                    lineDash: [4, 8],
                    lineDashOffset: 6
                }),
                image: new ol.style.Icon(({
                    anchor: [0.5, 0.5],
                    anchorOrigin: 'top-left',
                    offset: [0, 0],
                    scale: 1,
                    opacity: 1,
                    rotateWithView: false,
                    rotation: -rotation,
                    src: 'images/navi.png',
                }))
            });

            trackTempFeature.setStyle(trackStyle);
            source.addFeature(trackTempFeature);
            

            // var thisPointStyle = new ol.style.Style({
                // fill: new ol.style.Fill({
                //      color: '#424242'
                // }),
                // stroke: new ol.style.Stroke({
                //     color: '#1ea8caf3',
                //     width: 2,
                //     lineDash: [4, 8],
                //     lineDashOffset: 6
                // }),
                // image: new ol.style.Circle({
                //     radius: 5,
                //     fill: new ol.style.Fill({
                //         color: '#424242'
                //     })
                // }),
            // });
            // trackFeature.setStyle( thisPointStyle );
            // source.addFeature( trackFeature );
            

        },
        error: function(res, sts, err) {
            console.log(err);
        }
    });
}